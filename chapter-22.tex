\chapter{LOOP для мастеров с чёрным поясом}
\label{ch:22}

\thispagestyle{empty}

В~главе~\ref{ch:07} я кратко описал расширенный макрос \lstinline{LOOP}. Как я упоминал
тогда, \lstinline{LOOP} по существу предоставляет язык специального назначения для написания
конструкций итерирования.

Это может показаться весьма хлопотным: изобретение целого языка лишь для написания
циклов. Но если вы задумаетесь о способах использования циклов в программах, эта идея
действительно станет обретать смысл. Любая программа любого размера всег\-да будет содержать
циклы. И хотя все они не будут одинаковыми, они также не будут и совершенно различными;
при детальном рассмотрении будут выделены образцы (в частности, если включать в них код,
непосредственно предшествующий и следующий за циклами): образцы инициализации перед
циклом, образцы действий внутри цикла и образцы действий после завершения цикла. Язык
\lstinline{LOOP} фиксирует эти образцы, так что вы можете выражать их явно.

Макрос \lstinline{LOOP} имеет множество частей: одной из главных претензий противников
\lstinline{LOOP} является то, что он слишком сложен. В~этой главе я покажу, что это не так,
дав вам систематическое описание различных частей \lstinline{LOOP} и того, как эти части
использовать вместе.

\section{Части LOOP}

Вы можете делать в \lstinline{LOOP} следующее:

\begin{itemize}
\item итерировать переменную численно или по различным структурам данных;
\item собирать, подсчитывать, суммировать, искать максимальное и минимальное значения по
  данным, просматриваемым во время цикла;
\item выполнять произвольные выражения Lisp;
\item решать, когда остановить цикл;
\item осуществлять определённые действия при заданных условиях.
\end{itemize}

Вдобавок \lstinline{LOOP} предоставляет синтакс для следующего:

\begin{itemize}
\item создание локальных переменных для использования внутри цикла;
\item задание произвольных выражений Lisp для выполнения перед и после цикла.
\end{itemize}

Базовой структурой \lstinline{LOOP} является набор предложений (\textit{clauses}), каждое их
которых начинается с \textit{ключевого слова loop}\footnote{Термин \textit{ключевое слово
    loop} является несколько неудачным, так как ключевые слова loop не являются ключевыми
  словами в обычном смысле, то есть символами пакета KEYWORD. На самом деле ими могут быть
  любые символы с подходящими именами из любых пакетов: макрос \lstinline{LOOP} заботится
  только об их именах. Обычно же они записываются без спецификатора пакета и поэтому
  считываются (и интернируются при необходимости) в текущий пакет.}\hspace{\footnotenegspace}. То, как каждое
предложение анализируется макросом \lstinline{LOOP}, зависит от такого ключевого
слова. Некоторые из главных ключевых слов, которые вы видели в главе~\ref{ch:07},
следующие: for, collecting, summing, counting, do и finally.

\section{Управление итерированием}

Большинство из так называемых предложений управления итерированием начинаются с ключевого
слова \lstinline{loop} \lstinline{for} или его синонима \lstinline{as}\footnote{Так как одной из целей
  \lstinline{LOOP} является возможность записи выражений итерирования в синтаксисе, близком к
  английскому, многие ключевые слова имеют синонимы, которые трактуются \lstinline{LOOP} как
  одинаковые, но дают при этом некоторую свободу в выражении вещей на более естественном
  английском языке, учитывая различные контексты.}\hspace{\footnotenegspace}, за которыми следует имя переменной. Что
следует за именем переменной, зависит от типа предложения \lstinline{for}.

Подвыражения (subclauses) предложений \lstinline{for} могут итерировать по следующему:
\begin{itemize}
\item численные интервалы, вверх или вниз;
\item отдельные элементы списка;
\item cons-ячейки, составляющие список;
\item элементы вектора, включая подтипы, такие как строки и битовые векторы;
\item пары хэш-таблицы;
\item символы пакета;
\item результаты повторных вычислений заданной формы.
\end{itemize}

Одиночный цикл может содержать несколько предложений \lstinline{for}, каждое из которых именует
собственную переменную. Если цикл содержит несколько предложений \lstinline{for}, он
завершается, как только любое из них достигает своего условия завершения. Например,
следующий цикл:

\begin{myverb}
(loop
  for item in list
  for i from 1 to 10
  do (something))
\end{myverb}

выполнится максимум 10 раз, но может завершиться и раньше, если список содержим менее
десяти элементов.

\section{Подсчитывающие циклы (Counting Loops)}

Предложения арифметического итерирования управляют числом раз, которое будет выполнено
тело цикла, путём изменения переменной в пределах интервала чисел, выполняя тело на каждом
шаге. Такие предложения состоят из от одного до трёх сле\-дую\-щих \textit{предложных
  оборотов} (\textit{prepositional phrases}), идущих после \lstinline{for} (или \lstinline{as}):
оборот \textit{откуда} (\textit{from where}), оборот \textit{докуда} (\textit{to where}) и
оборот \textit{на сколько} (\textit{by how much}).

Оборот \textit{откуда} задаёт начальное значение для переменной предложения. Он состоит из
одного из предлогов (prepositions) \lstinline{from}, \lstinline{downfrom} или \lstinline{upfrom}, за
которыми следует форма, предоставляющая начальное значение (число).

Оборот \textit{докуда} задаёт точку останова цикла и состоит из одного из предлогов
\lstinline{to}, \lstinline{upto}, \lstinline{below}, \lstinline{downto} или \lstinline{above}, за которыми следует
форма, предоставляющая точку останова. С~\lstinline{upto} и \lstinline{downto} цикл завершится (без
выполнения тела), когда переменная перейдёт точку останова; с \lstinline{below} и \lstinline{above}
он завершится на итерацию ранее.

Оборот \textit{на сколько} состоит из предлога \lstinline{by} и формы, которая должна
вычисляться в положительное число. Переменная будет изменяться (вверх или вниз, что
определяется другими оборотами) на эту величину на каждой итерации или на единицу, если
оборот опущен.

Вы должны задать по меньшей мере один из этих предложных оборотов. По умолчанию цикл
начинается с нуля, переменная на каждой итерации увеличивается на единицу, и цикл
продолжается вечно или, более точно, пока другое предложение не остановит цикл. Вы можете
изменить любое из этих умолчаний путём добавления соответствующего предложного
оборота. Единственным неудобством является то, что если вы хотите декрементный цикл, не
существует значения \textit{откуда} по умолчанию, поэтому вы должны явно указать его с
помощью \lstinline{from} или \lstinline{downfrom}. Таким образом, следующее:

\begin{myverb}
(loop for i upto 10 collect i)
\end{myverb}

\noindent{}накапливает первые одиннадцать целых чисел (с нуля до десяти), но поведение этого:

\begin{myverb}
(loop for i downto -10 collect i)         ; неверно
\end{myverb}

\noindent{}не определено. Вместо этого вам нужно написать так:

\begin{myverb}
(loop for i from 0 downto -10 collect i)
\end{myverb}

Также заметьте, что так как \lstinline{LOOP} является макросом, который запускается во время
компиляции, то он может определить направление изменения переменной только по предлогам,
но не по зрачениям форм, которые не могут быть известны до времени выполнения. Поэтому
следующее:

\begin{myverb}
(loop for i from 10 to 20 ...) 
\end{myverb}

\noindent{}работает хорошо, используя значение приращения по умолчанию. Но это:

\begin{myverb}
(loop for i from 20 to 10 ...)
\end{myverb}

\noindent{}не знает, что нужно считать от двадцати до десяти. Хуже того, это выражение не выдаст вам
никакой ошибки: оно просто не выполнит цикл, так как i уже больше десяти. Вместо этого вы
должны написать так:

\begin{myverb}
(loop for i from 20 downto 10 ...)
\end{myverb}

\noindent{}или так:

\begin{myverb}
(loop for i downfrom 20 to 10 ...)
\end{myverb}

Наконец, если вам просто нужен цикл, повторяющийся определённое число раз, вы можете
заменить предложение следующей формы:

\begin{myverb}
for i from 1 to number-form
\end{myverb}

\noindent{}на предложение \lstinline{repeat} следующего вида:

\begin{myverb}
repeat number-form
\end{myverb}

Эти предложения идентичны по своему действию, за исключением того, что предложение
\lstinline{repeat} не создаёт явной переменной цикла.

\section{Организация циклов по коллекциям и пакетам}


Предложения \lstinline{for} для итерирования по спискам гораздо проще, чем арифметические
предложения. Они поддерживают только два предложных оборота: \lstinline{in} и \lstinline{on}.

Оборот такой формы:

\begin{myverb}
for var in list-form
\end{myverb}

\noindent{}итерирует переменную по всем элементам списка, являющегося результатом вычисления
\textit{list-form}.

\begin{myverb}
(loop for i in (list 10 20 30 40) collect i) ==> (10 20 30 40)
\end{myverb}

Иногда это предложение дополняется оборотом \lstinline{by}, который задаёт функцию для
продвижения по списку. Значением по умолчанию является \lstinline{CDR}, но можно использовать
любую функцию, принимающую список и возвращающую подсписок. Например, вы можете
накапливать каждый второй элемент списка с помощью loop следующим образом:

\begin{myverb}
(loop for i in (list 10 20 30 40) by #'cddr collect i) ==> (10 30)
\end{myverb}

Предложный оборот \lstinline{on} используется для итерирования по cons-ячейкам, сос\-тав\-ляю\-щим
список.

\begin{myverb}
(loop for x on (list 10 20 30) collect x) ==> ((10 20 30) (20 30) (30))
\end{myverb}

Этот оборот также принимает предлог \lstinline{by}:

\begin{myverb}
(loop for x on (list 10 20 30 40) by #'cddr collect x) ==> ((10 20 30 40) (30 40))
\end{myverb}

Итерирование по элементам вектора (что включает строки и битовые векторы) подобно
итерированию по элементам списка, за исключением использования предлога \lstinline{across}
вместо \lstinline{in}\footnote{Вас может удивить, почему \lstinline{LOOP} не может определить,
  итерирует ли он по списку или по вектору, без указания различных предлогов. Это ещё одно
  следствие того, что \lstinline{LOOP} является макросом: то, является значение списком или
  вектором, не может быть известно до времени выполнения, а \lstinline{LOOP} как макрос
  должен сгенерировать код во время компиляции. Также создатели \lstinline{LOOP} ставили
  целью генерацию максимально эффективного кода. Для генерации эффективного кода для
  итерирования, например по вектору, необходимо знать во время компиляции, что значением
  во время выполнения будет вектор, поэтому и нужны различные предлоги.}\hspace{\footnotenegspace}. Например:

\begin{myverb}
(loop for x across "abcd" collect x) ==> (#\bslash{}a #\bslash{}b #\bslash{}c #\bslash{}d)
\end{myverb}

Итерирование по хэш-таблице или пакету немного более сложно, так как хэш-таблицы и пакеты
содержат различные множества значений, по которым вы можете захотеть итерировать: ключи
или значения в хэш-таблице или различные виды символов в пакете. Оба вида итерирования
следуют сходному образцу, который в базовом виде выглядит так:

\begin{myverb}
(loop for var being the things in hash-or-package ...)
\end{myverb}

Для хэш-таблиц возможными значениями для \textit{things} являются \lstinline{hash-keys} и
\lstinline{hash-values}, означающие, что \lstinline{var} будет связываться с последовательными
значениями ключей или самими значениями хэш-таблицы соответственно. Форма
\textit{hash-or-package} вычисляется лишь один раз для получения значения, которое должно
быть хэш-таблицей.

Для итерирования по пакету \textit{things} может быть \lstinline{symbols},
\lstinline{present-symbols} и \lstinline{external-symbols}, и \textit{var} будет связываться с
каждым символом, доступным в пакете, каждым символом, присутствующим в пакете (другими
словами, интернированным или импортированным в этот пакет), или с каждым символом,
экспортированным из пакета соответственно. Форма \textit{hash-or-package} вычисляется для
предоставления имени пакета, который будет искаться как с помощью \lstinline{FIND-PACKAGE},
или объекта пакета. Для частей предложения \lstinline{for} также доступны синонимы. На месте
\lstinline{the} вы можете использовать \lstinline{each} вместо \lstinline{in}~--- \lstinline{of}, а также
\textit{things} можно записывать в единственном числе (например, \lstinline{hash-key} или
\lstinline{symbol}).

И наконец, так как часто при итерировании по хэш-таблицам нужны и ключи, и сами значения,
предложения для хэш-таблиц поддерживают использование специального
\lstinline{using}-подпредложения.

\begin{myverb}
(loop for k being the hash-keys in h using (hash-value v) ...)
(loop for v being the hash-values in h using (hash-key k) ...)
\end{myverb}

Оба этих цикла будут связывать \lstinline{k} с каждым ключом в хэш-таблице, а \lstinline{v}~--- с
соответствующим значением. Обратите внимание, что первый элемент
\lstinline{using}-подпредложения должен быть записан в единственном числе\footnote{Даже не
    спрашивайте меня, почему авторы \lstinline{LOOP} отступили от стиля без скобок для
    \lstinline{using}-подпредложения.}\hspace{\footnotenegspace}.

\section{Equals-Then--итерирование}

Если ни одно из остальных предложений \lstinline{for} не предоставляет именно ту форму
итерирования переменной, которая вам нужна, вы можете получить полный контроль над
итерированием, используя предложение \textit{equals-then}. Это предложение подобно
связывающим предложениям (binding clauses) в циклах \lstinline{DO}, приведённых к более
Algol-подобному синтаксису. Образец использования следующий:

\begin{myverb}
(loop for var = initial-value-form [ then step-form ] ...)
\end{myverb}

Как обычно, \textit{var}~--- имя итерируемой переменной. Её начальное значение получается
путём однократного вычисления \textit{initial-value-form} перед первой итерацией. На
каждой последующей итерации вычисляется \textit{step-form}, и её значение становится новым
значением \textit{var}. В~отсутствие \lstinline{then}-части предложения
\textit{initial-value-form} перевычисляется на каждой итерации для предоставления нового
значения. Заметьте, что это отличается от связывающего проедложения \lstinline{DO} без
step-формы.

\textit{step-form} может ссылать на другие переменные loop, включая переменные, созданные
другими предложениями \lstinline{for} цикла loop. Например:

\begin{myverb}
(loop repeat 5 
      for x = 0 then y
      for y = 1 then (+ x y)
      collect y) ==> (1 2 4 8 16)
\end{myverb}

Заметьте, однако, что каждое предложение \lstinline{for} вычисляется отдельно в порядке своего
появления. Поэтому в предыдущем цикле на второй итерации \lstinline{x} устанавливается в
значение \lstinline{y} до того, как \lstinline{y} изменится (другими словами, в 1). Но \lstinline{y}
затем устанавливает в значение суммы своего старого значения (все ещё 1) и нового значения
\lstinline{x}. Если порядок предложений \lstinline{for} изменить, результат изменится.

\begin{myverb}
(loop repeat 5
      for y = 1 then (+ x y)
      for x = 0 then y
      collect y) ==> (1 1 2 4 8)
\end{myverb}

Часто, однако, вам нужно, чтобы \lstinline{step}-формы для нескольких переменных были вычислены перед
тем, как любая из этих переменных получит своё новое значение (подобно тому, как это
происходит в \lstinline{DO}). В~этом случае вы можете объединить несколько предложений
\lstinline{for}, заменив все, кроме первого \lstinline{for}, на \lstinline{and}. Вы уже видели такую запись
в \lstinline{LOOP}-версии вычисления чисел Фибоначчи в главе~\ref{ch:07}. Вот другой вариант,
основанный на двух предыдущих примерах:

\begin{myverb}
(loop repeat 5 
      for x = 0 then y
      and y = 1 then (+ x y)
      collect y) ==> (1 1 2 3 5)
\end{myverb}

\section{Локальные переменные}

В~то время как главные переменные, необходимые внутри цикла, обычно явно объявляются в
предложениях \lstinline{for}, иногда вам понадобятся вспомогательные переменные, которые вы
можете объявить с помощью предложений \lstinline{with}.

\begin{myverb}
with var [ = value-form ]
\end{myverb}

Имя \textit{var} станет именем локальной переменной, которая перестанет существовать после
завершения цикла. Если предложение \lstinline{with} содержит часть \lstinline{= value-form}, то
перед первой итерацией цикла переменная будет проинициализирована значением
\textit{value-form}.

В~loop может быть несколько предложений \lstinline{with}; каждое предложение вычисляется
независимо в порядке их появления, и значение присваивается перед началом обработки
следующего предложения, что позволяет последующим переменным зависеть от значения уже
объявленных переменных. Взаимно независимые переменные могут быть объявлены в одном
предложении \lstinline{with} с использованием \lstinline{and} между такими дек\-ла\-ра\-ция\-ми.

\section{Деструктурирование переменных}

Очень удобной возможностью \lstinline{LOOP}, о которой я ранее не упоминал, является
возможность деструктурирования списковых значений, присваемых переменным цикла. Это
позволяет разбирать на части значение списков, которые иначе присваивались бы переменной
цикла, подобно тому, как работает \lstinline{DESTRUCTURING-BIND}, но немного более простым
способом. В~общем, вы можете заменить любую переменную цикла в предложениях \lstinline{for} или
\lstinline{with} деревом символов, и списковое значение, которое было бы присвоено простой
переменной, будет деструктурировано на переменные, именованные символами дерева. Простой
пример выглядит следующим образом:

\begin{myverb}
CL-USER> (loop for (a b) in '((1 2) (3 4) (5 6))
            do (format t "a: ~a; b: ~a~%" a b))
a: 1; b: 2
a: 3; b: 4
a: 5; b: 6
NIL
\end{myverb}

Такое дерево также может включать в себя точечные пары. В~этом случае имя после точки
работает как \lstinline!&rest! параметр: с ним будет связан список, содержащий все
оставшиеся элементы списка. Это особенно полезно с \lstinline{for/on} циклом, так как значением
всегда является список. Например, этот \lstinline{LOOP} (который я использовал в
главе~\ref{ch:18} для вывода элементов списка, разделённых запятыми):

\begin{myverb}
(loop for cons on list
    do (format t "~a" (car cons))
    when (cdr cons) do (format t ", "))
\end{myverb}

\noindent{}может также быть записан следующим образом:

\begin{myverb}
(loop for (item . rest) on list
    do (format t "~a" item)
    when rest do (format t ", "))
\end{myverb}

Если вы хотите игнорировать значение деструктурированного списка, вы можете использовать
\lstinline{NIL} на месте имени переменной.

\begin{myverb}
  (loop for (a nil) in '((1 2) (3 4) (5 6)) collect a) ==> (1 3 5)
\end{myverb}

Если список деструктурирования содержит больше переменных, чем значений в списке, лишние
переменные получают значение \lstinline{NIL}, что делает переменные, по существу, похожими на
\lstinline!&optional! параметры. Не существует, однако, эквивалента \lstinline!&key!
параметрам.

\section{Накопление значения}

Предложения накопления значения, вероятно, являются наиболее мощной частью
\lstinline{LOOP}. Хотя предложения управления итерированием предоставляют лаконичный
синтаксис для выражения базовых механизмов итерирования, они не отличаются разительно от
подобных механизмов, предоставляемых \lstinline{DO}, \lstinline{DOLIST} и \lstinline{DOTIMES}.

С другой стороны, операторы накопления значения предоставляют возможность лаконичной
записи общих идиом накопления во время итерирования. Каждое предожение накопления
начинается с глагола и следует следующему образцу:

\begin{myverb}
verb form [ into var ]
\end{myverb}

Каждый раз при прохождении цикла предложение накопления вычисляет \textit{form} и
сохраняет значение способом, определяемым глаголом \textit{verb}. С подпредложением
\lstinline{into} значение сохраняется в переменную под именем \textit{var}. Переменная является
локальной в цикле, как если бы она была объявлена в предложении \lstinline{with}. Без
подпредложения \lstinline{into} предложение накопления накапливает значения в переменную по
умолчанию для всего выражения цикла.

Возможными глаголами являются \lstinline{collect}, \lstinline{append}, \lstinline{nconc}, \lstinline{count},
\lstinline{sum}, \lstinline{maximize} и \lstinline{minimize}. Также доступны синонимы в форме причастий
настоящего времени: \lstinline{collecting}, \lstinline{appending}, \lstinline{nconcing}, \lstinline{counting},
\lstinline{summing}, \lstinline{maximizing} и \lstinline{minimizing}.

Предложение \lstinline{collect} строит список, содержащий все значения \textit{form} в порядке
их просмотра. Эта конструкция особенно полезна, так как код, который вы бы написали для
накопления списка, равный по эффективности сгенерированному \lstinline{LOOP} коду, будет
гораздо более сложным, чем вы обычно пишете вручную\footnote{Трюк заключается в удержании
  хвоста списка и добавления новых cons-ячеек путём \lstinline{SETF} \lstinline{CDR}'а
  хвоста. Написанный вручную эквивалент кода, генерируемого \lstinline{(loop for i upto 10 collect i)},
  будет выглядеть подобным образом:

\begin{myverb}
(do ((list nil) (tail nil) (i 0 (1+ i)))
    ((> i 10) list)
  (let ((new (cons i nil)))
    (if (null list)
        (setf list new)
        (setf (cdr tail) new))
    (setf tail new)))
\end{myverb}

Конечно, вы редко, если вообще, будете писать подобный код. Вы будете использовать либо
\lstinline{LOOP}, либо, если по каким-то причинам вы не захотите использовать \lstinline{LOOP},
стандартную идиому \lstinline{PUSH}/\lstinline{NREVERSE} накопления значений.}\hspace{\footnotenegspace}. Родственными
\lstinline{collect} являются глаголы \lstinline{append} и \lstinline{nconc}.  Эти глаголы также
накапливают значения в список, но они объединяют значения, которые должны быть списками, в
единый список, как с помощью функций \lstinline{APPEND} и \lstinline{NCONC}\footnote{Напомним,
  что \lstinline{NCONC} является деструктивной версией \lstinline{APPEND}~--- использование
  предложения \lstinline{nconc} безопасно только в том случае, если накапливаемые вами значения
  являются новыми списками, которые не разделяют какую-либо свою структуру с другими
  списками. Например, это безопасно:

\begin{myverb}
(loop for i upto 3 nconc (list i i)) ==> (0 0 1 1 2 2 3 3)
\end{myverb}

Но это доставит вам хлопот:

\begin{myverb}
(loop for i on (list 1 2 3) nconc i) ==> неопределено
\end{myverb}

Последнее, наиболее вероятно, зациклится навечно, так как различные части списка, созданного
с помощью \lstinline{(list 1 2 3)}, будут деструктивно модифицированы, указывая друг на
друга. Но даже это не гарантируется~--- поведение просто не определено.}\hspace{\footnotenegspace}.

Остальные предложения накопления значения используются для накопления численных
значений. Глагол \lstinline{count} подсчитывает число раз, которое форма \textit{form} была
истинна, \lstinline{sum} подсчитывает сумму значений, которые принимала форма \textit{form},
\lstinline{maximize} подсчитывает максимальное из этих значений, а \lstinline{minimize}~---
минимальное. Представим, например, что вы определили переменную \lstinline{*random*},
содержащую список случайных чисел.

\begin{myverb}
(defparameter *random* (loop repeat 100 collect (random 10000)))
\end{myverb}

Следующий цикл вернёт список, содержащий различную сводную информацию о числах из
\lstinline{*random*}:

\begin{myverb}
(loop for i in *random*
   counting (evenp i) into evens
   counting (oddp i) into odds
   summing i into total
   maximizing i into max
   minimizing i into min
   finally (return (list min max total evens odds)))
\end{myverb}

\section{Безусловное выполнение}

Хоть и удобная для конструкций накопления значения, LOOP не была бы очень хорошим
средством итерации общего назначения, если бы не предоставляла способа выполнения
произвольного кода в теле цикла.

Самым простым способом выполнения произвольного кода внутри тела цикла является
использование предложения \lstinline{do}. По сравнению с вышеописанными предложениями со всеми
их предлогами и подвыражениями, \lstinline{do} следует модели простоты по Йоде\pclfootnote{<<Нет!
  Не пытайся. Делай... или не делай. Но не пытайся>>.~--- Йода, Империя наносит ответный
  удар.}. Предложение \lstinline{do} состоит из слова \lstinline{do} (или \lstinline{doing}), за которым
следует одна или более форм Lisp, которые вычисляются при вычислении предложения
\lstinline{do}. Предложение \lstinline{do} заканчивается закрывающей скобкой цикла loop или
следующим ключевым словом loop.

Например, для печати чисел от одного до десяти вы можете записать следующее:

\begin{myverb}
(loop for i from 1 to 10 do (print i))
\end{myverb}

Еще одной формой непосредственного выполнения является предложение \lstinline{return}. Это
предложение состоит из слова \lstinline{return}, за которым следует одна форма Lisp, которая
вычисляется, а результат немедленно возвращается как значение цикла loop.

Вы также можете прервать цикл из предложения \lstinline{do} путём использования любого обычного
оператора управления потоком вычислений Lisp, таких как \lstinline{RETURN} и
\lstinline{RETURN-FROM}. Обратите внимание, что предложение \lstinline{return} всегда возвращает
управление из непосредственно охватывающего выражения \lstinline{LOOP}, в то время как с
помощью \lstinline{RETURN} и \lstinline{RETURN-FROM} в предложении \lstinline{do} можно вернуть
управление из любого охватывающего выражения. Например, сравните следующее:

\begin{myverb}
(block outer
  (loop for i from 0 return 100) ; 100 возвращается из LOOP
  (print "This will print")
  200) ==> 200
\end{myverb}

\noindent{}с этим:

\begin{myverb}
(block outer
  (loop for i from 0 do (return-from outer 100)) ; 100 возвращается из BLOCK
  (print "This won't print")
  200) ==> 100
\end{myverb}

Предложения \lstinline{do} и \lstinline{return} вместе называются предложениями безусловного
выполнения.

\section{Условное выполнение}

Так как предложение \lstinline{do} может содержать произвольные формы Lisp, вы можете
использовать любые выражения Lisp, включая конструкции управления, такие как \lstinline{IF} и
\lstinline{WHEN}. Таким образом, следующее является одним из способов написания цикла,
печатающего только чётные числа от одного до десяти:

\begin{myverb}
(loop for i from 1 to 10 do (when (evenp i) (print i)))
\end{myverb}

Однако иногда вам понадобится условное управление на уровне предложений цикла
loop. Например, представим, что вам нужно просуммировать только чётные числа от одного до
десяти путём использования предложения \lstinline{summing}. Вы не сможете написать такой цикл с
помощью предложения \lstinline{do}, так как не существует способа <<вызвать>> \lstinline{sum i} в
середине обычной формы Lisp. В~случаях, подобных этому, вам нужно использовать одно из
собственных условных выражений \lstinline{LOOP}:

\begin{myverb}
(loop for i from 1 to 10 when (evenp i) sum i) ==> 30
\end{myverb}

\lstinline{LOOP} предоставляет три условные конструкции, и все они следуют этому базовому образцу:

\begin{myverb}
conditional test-form loop-clause
\end{myverb}

Условный оператор \textit{conditional} может быть \lstinline{if}, \lstinline{when} или
\lstinline{unless}. \textit{test-form}~--- это любая обычная форма Lisp, а предложение
\textit{loop-clause} может быть предложением накопления значения (\lstinline{count},
\lstinline{collect} и т.~д.), предложением безусловного выполнения или другим предложением
условного выполнения. Несколько предложений цикла могут быть объединены в одну условную
конструкцию путём соединения их с помощью \lstinline{and}.

Несколько условных предложений могут быть объединены в одно условное путём соединения их
с помощью \lstinline{and}.

Дополнительным синтаксическим сахаром является возможность использования в первом
предложении loop после формы условия переменной \lstinline{it} для ссылки на значение,
возвращённое этой формой условия. Например, следующий цикл накапливает не равные
\lstinline{NIL} значения, найденные в \lstinline{some-hash} по ключам из \lstinline{some-list}:

\begin{myverb}
(loop for key in some-list when (gethash key some-hash) collect it)
\end{myverb}

Условное выражение выполняется при каждой итерации цикла. Предложения \lstinline{if} и
\lstinline{when} выполняют свои предложения loop, если форма \textit{test-form} вычисляется в
истину. \lstinline{unless} же выполняет предложения, только если \textit{test-form} вычисляется
в \lstinline{NIL}. В~отличие от так же названных операторов Common Lisp, \lstinline{if} и
\lstinline{when} в \lstinline{LOOP} являются синонимами~--- в их поведении нет никакой разницы.

Все три условных предложения могут также принимать ветвь \lstinline{else}, в которой за
\lstinline{else} следует другое предложение loop либо несколько предложений, объединённых
\lstinline{and}. Если условные предложения являются вложенными, множество предложений,
связанных с внутренним условным предложением, может быть завершено с помощью слова
\lstinline{end}. \lstinline{end} является необязательным, если оно не нужно для разрешения
неоднозначности с вложенными условными предложениями: конец условного предложения будет
определён по концу цикла либо по началу другого предложения, не присоединённого с помощью
\lstinline{and}.

Следующий довольно глупый цикл демонстрирует различные формы условных предложений
\lstinline{LOOP}. Функция \lstinline{update-analysis} будет вызываться на каждой итерации цикла с
последними значениями различных переменных, накапливаемых пред\-ло\-же\-ния\-ми внутри условных
предложений.

\begin{myverb}
(loop for i from 1 to 100
      if (evenp i)
        minimize i into min-even and 
        maximize i into max-even and
        unless (zerop (mod i 4))
          sum i into even-not-fours-total
        end
        and sum i into even-total
      else
        minimize i into min-odd and
        maximize i into max-odd and
        when (zerop (mod i 5)) 
          sum i into fives-total
        end
        and sum i into odd-total
      do (update-analysis min-even
                          max-even
                          min-odd
                          max-odd
                          even-total
                          odd-total
                          fives-total
                          even-not-fours-total))
\end{myverb}

\section{Начальные установки и подытоживание}

Одним из ключевых озарений проектировщиков языка \lstinline{LOOP} было осознание того, что
циклы часто предваряются некоторым кодом, занимающимся начальной установкой каких-то
вещей, и завершаются кодом, осуществляющим что-то со значениями, вычисленными в
цикле. Простой пример на Perl\pclfootnote{Я не придираюсь к Perl здесь~--- этот пример
  выглядел бы примерно так же на любом языке с основанным на C синтаксисом.} мог бы
выглядеть так:

\begin{lstlisting}[language=Perl]
my $evens_sum = 0;
  my $odds_sum  = 0;
  foreach my $i (@list_of_numbers) {
    if ($i % 2) {
      $odds_sum += $i;
    } else {
      $evens_sum += $i;
    }
  }
  if ($evens_sum > $odds_sum) {
    print "Sum of evens greater\n";
  } else {
    print "Sum of odds greater\n";
  }
\end{lstlisting}

Циклической сущностью в этом коде является инструкция \lstinline{foreach}. Но сам цикл
\lstinline{foreach} не является независимым: код в теле цикла ссылается на переменные,
объявленные в двух строках перед циклом\footnote{Perl позволяет вам не объявлять
  переменные, если вы не используете режима \lstinline{strict}. Но вам следует \textit{всегда}
  использовать его в Perl. Эквивалентный код на Python, Java или C потребовал бы
  обязательного объявления переменных.}\hspace{\footnotenegspace}. А работа, осуществляемая циклом, является
абсолютно бесполезной без инструкции \lstinline{if} после цикла, которая фактически сообщает о
результате. В~Common Lisp к тому же конструкция \lstinline{LOOP} является выражением,
возвращающим значение, и поэтому потребность в осуществлении чего-либо, а именно генерации
возвращаемого значения, даже больше.

Поэтому проектировщики \lstinline{LOOP} предоставили возможность включения такого, на самом
деле являющегося частью цикла, кода в сам цикл. Для этого \lstinline{LOOP} предоставляет два
ключевых слова, \lstinline{initially} и \lstinline{finally}, которые вводят код для запуска снаружи
главного тела цикла.

После слов \lstinline{initially} или \lstinline{finally} эти предложения включают все формы Lisp до
начала следующего предложения цикла либо до его конца. Все формы \lstinline{initially}
комбинируются в единую \textit{вводную часть} (\textit{prologue}), которая запускается
однократно непосредственно после инициализации всех локальных переменных цикла и перед его
телом. Формы \lstinline{finally} схожим образом комбинируются в \textit{заключительную часть}
(\textit{epilogue}) и выполняются после последней итерации цикла. И вводная, и
заключительная части могут ссылаться на локальные пемеренные цикла.

Вводная часть всегда запускается, даже если тело цикла не выполняется ни разу. В~то же
время цикл может вернуть значение без выполнения заключительной части в одном из следующих
случаев:
\begin{itemize}
\item выполнение предложения \lstinline{return};
\item \lstinline{RETURN}, \lstinline{RETURN-FROM} или другая конструкция передачи управления
  была вызвана из формы Lisp, находящейся в теле цикла\footnote{Вы можете нормально, с
    запуском заключительной части, завершить цикл из кода Lisp, вы\-пол\-няе\-мо\-го как часть
    тела цикла, с помощью локального макроса \lstinline{LOOP-FINISH}.}\hspace{\footnotenegspace};
\item цикл завершается по предложению \lstinline{always}, \lstinline{nerver} или \lstinline{thereis},
  которые я проанализирую в следующем разделе.
\end{itemize}

Внутри кода заключительной части для явного предоставления возвращаемого циклом значения
может использоваться \lstinline{RETURN} или \lstinline{RETURN-FROM}. Это явно возвращаемое
значение имеет приоритет над любым значением, которое может иначе предоставляться
предложениями накопления или критерия остановки.

Для возможности использования \lstinline{RETURN-FROM} для возврата из указываемого цикла
(полезно при вложенных выражениях \lstinline{LOOP}) вы можете дать \lstinline{LOOP} имя с
помощью ключевого слова loop \lstinline{named}. Если предложение \lstinline{named} используется в
цикле, оно должно идти первым. В~качестве простого примера предположим, что у вас есть
список списков, и вы хотите найти в одном из вложенных списков элемент, который
удовлетворяет некоторому критерию. Вы можете найти его с помощью пары вложенных циклов
подобным образом:

\begin{myverb}
(loop named outer for list in lists do
     (loop for item in list do
          (if (what-i-am-looking-for-p item)
            (return-from outer item))))
\end{myverb}

\section{Критерии завершения}

Хотя предложения \lstinline{for} и \lstinline{repeat} предоставляют базовую инфраструктуру для
управления числом итераций, иногда вам понадобится прервать цикл до его завершения. Вы уже
видели, как с помощью предложения \lstinline{return} или операторов \lstinline{RETURN} и
\lstinline{RETURN-FROM} внутри предложения \lstinline{do} можно немедленно прервать цикл; но как
есть общие образцы для накопления значений, так существуют и общие образцы для принятия
решений, когда останавливать цикл. Такие образцы поддерживаются в \lstinline{LOOP} с помощью
предложений завершения \lstinline{while}, \lstinline{until}, \lstinline{always}, \lstinline{never} и
\lstinline{thereis}. Все они следуют одинаковому образцу:

\begin{myverb}
loop-keyword test-form
\end{myverb}

Все эти предложения вычисляют форму \textit{test-form} на каждой итерации и на основе
возвращаемого ей значения принимают решение, завершить ли выполнение цикла. Они отличаются
в том, что происходит при завершении ими цикла (если он завершается) и как они определяют
необходимость такого завершения.

Ключевые слова \lstinline{loop} \lstinline{while} и \lstinline{until} предоставляют <<мягкие>> предложения
завершения. Если они решают завершить цикл, управление передаётся в заключительную часть,
пропуская оставшуюся часть тела цикла. Затем заключительная часть может вернуть значение
или сделать ещё что-либо для завершения цикла. Предложение \lstinline{while} останавливает цикл,
как только контрольная форма \textit{test-form} вычисляется в ложное значение, а
\lstinline{until}, наоборот,~--- как только в истинное.

Другая форма мягкого завершения предоставляется макросом \lstinline{LOOP-FINISH}. Это обычная
форма Lisp, не предложение loop, поэтому она может использоваться в любом месте внутри
форм Lisp предложения \lstinline{do}. \lstinline{LOOP-FINISH} также приводит к немедленному
переходу к заключительной части и может быть полезен, когда решение о прерывании цикла не
может быть легко умещено в единственную форму, могущую использоваться в предложениях
\lstinline{while} или \lstinline{until}.

Остальные три предложения, \lstinline{always}, \lstinline{never} и \lstinline{thereis}, останавливают
цикл гораздо более жёстко: они приводят к немедленному возврату из цикла, пропуская не
только все последующие предложения loop, но и заключительную часть. Они также
предоставляют значение по умолчанию, даже если не приводят к завершению цикла. Однако, если
цикл не завершается ни по одному из этих критериев, заключительная часть запускается и
может вернуть значение, отличное от значения по умолчанию, предоставляемого предложениями
завершения.

Так как эти предложения предоставляют свои собственные возвращаемые значения, они не могут
комбинироваться с предложениями накопления, за исключением содержащих подвыражение
\lstinline{into}. Иначе компилятор (или интерпретатор) должен просигнализировать ошибку во
время выполнения. Предложения \lstinline{always} и \lstinline{never} возвращают только булевы
значения, поэтому они наиболее полезны в случае, если вам нужно использовать выражение
цикла как часть предиката. Вы можете использовать \lstinline{always} для проверки того, что
контрольная форма вычисляется в истинное значение на каждой итерации цикла. И наоборот,
\lstinline{never} проверяет, что контрольная форма на каждой итерации вычисляется в
\lstinline{NIL}. Если контрольная форма <<не срабатывает>> (возвращает \lstinline{NIL} в
предложении \lstinline{always} или не \lstinline{NIL} в предложении \lstinline{never}), цикл немедленно
прерывается, возвращая \lstinline{NIL}. Если же цикл выполняется до конца, предоставляется
значение по умолчанию: \lstinline{T}.

Например, если вы хотите проверить, что все числа в списке \lstinline{numbers} являются
чётными, вы можете написать следующее:

\begin{myverb}
(if (loop for n in numbers always (evenp n))
    (print "All numbers even."))
\end{myverb}

Также вы можете записать следующее:

\begin{myverb}
(if (loop for n in numbers never (oddp n))
    (print "All numbers even."))
\end{myverb}

Предложение \lstinline{thereis} используется для проверки, вычисляется ли контрольная форма в
истинное значение хотя бы раз. Как только контрольная форма возвращает значение, не равное
\lstinline{NULL}, цикл останавливается, возвращая это значение. Если же цикл доходит до
конца, предложение \lstinline{thereis} предоставляет возвращаемое значение по умолчанию:
\lstinline{NIL}.

\begin{myverb}
(loop for char across "abc123" thereis (digit-char-p char)) ==> 1

(loop for char across "abcdef" thereis (digit-char-p char)) ==> NIL
\end{myverb}

\section{Сложим все вместе}

Вы увидели все основные возможности \lstinline{LOOP}. Вы можете комбинировать все вышеобсуждённые
предложения, следуя следующим правилам:

\begin{itemize}
\item Предложение \lstinline{named}, если указывается, должно быть первым предложением.
\item После предложения \lstinline{named} идут все остальные предложения \lstinline{initially},
  \lstinline{with}, \lstinline{for} и \lstinline{repeat}.
\item Затем идут предложения тела: условного и безусловного выполнения, накопления,
  критериев завершения\footnote{Некоторые реализации Common Lisp позволяют вам смешивать
    предложения тела и предложения \lstinline{for}, но это не специфицировано, поэтому другие
    реализации отвергнут такие циклы.}\hspace{\footnotenegspace}.
\item Завершается цикл предложениями \lstinline{finally}.
\end{itemize}

Макрос \lstinline{LOOP} раскрывается в код, который осуществляет следующие действия:

\begin{itemize}
\item инициализирует все локальные переменные цикла, которые объявлены в предложениях
  \lstinline{with} или \lstinline{for}, а также неявно созданы предложениями накопления. Начальные
  значения форм вычисляются в порядке появления соответствующих предложений в цикле;
\item выполняет формы, предоставляемые предложениями \lstinline{initially} (вводная часть), в
  порядке их появления в цикле;
\item итерирует, выполняя тело цикла как описано в следующем абзаце;
\item выполняет формы, предоставляемые предложениями \lstinline{finally} (заключительная
  часть), в порядке их появления в цикле.
\end{itemize}

Во время работы цикла сначала соответствующим образом изменяются все переменные управления
итерацией, а затем выполняются все предложения условного и безус\-лов\-но\-го выполнения,
накопления, критериев завершения в том порядке, в каком они появляются в коде цикла. Если
любое из предложений тела цикла завершает цикл, оставшаяся часть тела пропускается и
происходит возврат из цикла, возможно, после выполнения завершающей части.

И это описывает почти все, связанное с \lstinline{LOOP}\footnote{Одним из аспектов
  \lstinline{LOOP}, которого я даже не касался, является синтаксис объявления типов
  переменных цикла. Конечно, я также не обсуждал и объявление типов вне
  \lstinline{LOOP}. Последнее я вкратце проанализирую в главе~\ref{ch:32}. Для информации же о том,
  как декларации типов работают с \lstinline{LOOP}, обратитесь к вашему любимому справочнику
  по Common Lisp.}\hspace{\footnotenegspace}. Вы будете использовать \lstinline{LOOP} далее в этой книге довольно
часто, поэтому стоило получить некоторое представление о нем. Ну а после вам самим решать,
насколько интенсивно использовать \lstinline{LOOP}.

И теперь вы готовы к погружению в практические главы, составляющие оставшуюся часть этой
книги. Для начала мы напишем антиспамовый фильтр.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
