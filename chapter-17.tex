\chapter{Переходим к объектам: Классы}
\label{ch:17}

Если обобщённые функции являются глаголами объектной системы, то классы являются
существительными.  Как я упоминал в предыдущей главе, все значения в программах на Common
Lisp являются экземплярами какого-то из классов.  Более того, все классы образуют иерархию
на вершине которой находится класс \code{T}.

Иерархия классов состоит из двух основных семейств классов: встроенных и определённых
пользователем.  Классы, которые представляют типы данных, которые мы изучали до сих
пор~--- такие как \code{INTEGER}, \code{STRING} и \code{LIST}, являются встроенными.  Они
находятся в отдельном разделе иерархии классов, организованные соответствующими связями
дочерних и родительских классов, и для работы с ними используются функции, которые я
описывал на протяжении всей книги.  Вы не можете унаследовать от этих классов, но как вы
увидели в предыдущем разделе, вы можете определить специализированные методы для них,
эффективно расширяя поведения этих классов.\footnote{Определение новых методов для
    существующих классов может показаться странным для людей, которые использовали
    статически типизированные языки, такие как C++ и Java, в которых все методы классов
    должны быть определены как часть определения класса.  А вот программисты, которые
    имеют опыт программирования на Smalltalk и Objective C не найдут в этой
функциональности ничего странного.}

Но когда вы создаёте новые существительные~--- например, классы, которые использовались в
предыдущей главе для представления банковских счетов, то вам нужно определить ваши
собственные классы.  Это и будет темой данной главы.

\section{DEFCLASS}

Вы можете создать собственный класс с помощью макроса \code{DEFCLASS}.  Поскольку
поведение класса определяется обобщёнными функциями, и методами, специализированными для
класса, то \code{DEFCLASS} отвечает только за определение класса как типа данных.

Класс, как тип данных, состоит из трёх частей: имени, отношения к другим классам и имен
слотов.\footnote{В других объектно-ориентированных языках слоты могут называться полями,
переменными-членами класса или аттрибутами.}  Базовая форма \code{DEFCLASS} выглядит
достаточно просто.

\begin{lstlisting}
(defclass name (direct-superclass-name*)
  (slot-specifier*))
\end{lstlisting}

Что такое классы, определённые пользователем?

<<Определённые пользователем классы>>~--- термин не из стандарта языка. Определёнными
пользователем классами я называю подклассы класса \code{STANDARD-OBJECT}, а также классы,
у которых метакласс~--- \code{STANDARD-CLASS}. Но поскольку я не собираюсь говорить о
способах определения классов, которые не наследуют \code{STANDARD-OBJECT} и чей метакласс
~--- это не \code{STANDARD-CLASS}, вам можно не обращать на это внимания. Определённые
пользователем~--- не идеальный термин, потому что реализация может определять некоторые
классы таким же способом. Но ещё большей путаницей будет называть эти классы стандартными,
поскольку встроенные классы (например, \code{INTEGER} и \code{STRING}) тоже стандартные,
если не сказать больше, потому что они определены стандартом языка, но они не расширяют
(не наследуют) \code{STANDARD-OBJECT}. Чтобы ещё больше запутать дело, пользователь может
также определять классы, не наследующие \code{STANDARD-OBJECT}. В частности, макрос
\code{DEFSTRUCT} тоже определяет новые классы. Но это во многом для обратной совместимости
~--- \code{DEFSTRUCT} появился раньше, чем CLOS и был изменён, чтоб определять классы, когда
CLOS добавлялся в язык. Но создаваемые им классы достаточно ограничены по сравнению с
классами, созданными с помощью \code{DEFCLASS}. Итак, я буду обсуждать только классы,
создаваемые с помощью \code{DEFCLASS}, которые используют заданный по умолчанию метакласс
\code{STANDARD-CLASS} и, за неимением лучшего термина, назову их <<определёнными
пользователем классами>>.

Также как с функциями и переменными, вы можете использовать в качестве имени класса любой
символ.\footnote{Также, как и при именовании функции и переменных, это не совсем правда,
  что вы можете использовать для класса любое имя~--- вы не можете использовать имена,
  определённые стандартом.  В главе~\ref{ch:21} вы увидите как можно избежать таких конфликтов
  имён.}  Имена классов находятся в собственном пространстве имён, отдельно от имен
функций и переменных, так что вы можете задать для класса то же самое имя, что и
существующие функция и переменная.  Вы будете использовать имя класса в качестве аргумента
функции \code{MAKE-INSTANCE}, которая создаёт новые экземпляры классов, определённых
пользователем.

Опция \code{direct-superclass-names} используется для указания имён классов, от которых
будет проводиться наследование данного класса.  Если ни одного класса не указано, то он
будет унаследован от \code{STANDARD-OBJECT}.  Все классы, указанные в данной опции, должны
быть классами, определёнными пользователем, чтобы быть увереным, что каждый новый класс
происходит от \code{STANDARD-OBJECT}.  \code{STANDARD-OBJECT} является подклассом
\code{T}, так что все классы, определённые пользователем, являются частью одной иерархии
классов, которая также содержит все встроенные классы.

На время отвлекаясь от упоминания спецификаторов слотов, запись \code{DEFCLASS} для
некоторых из классов, которые мы использовали в предыдущей главе, может выглядеть
следующим образом:

\begin{lstlisting}
(defclass bank-account () ...)

(defclass checking-account (bank-account) ...)

(defclass savings-account (bank-account) ...)
\end{lstlisting}

В разделе~\ref{sec:17-multi-inheritance} я объясню, что означает указание более чем одного
суперкласса в списке опции \code{direct-superclass-names}.

\section{Спецификаторы слотов}

Большая часть \code{DEFCLASS} состоит из списка спецификаторов слотов.  Каждый
спецификатор определяет слот, который будет частью экземпляра класса.  Каждый слот в
экземпляре является местом, которое может хранить значение, к которому можно получить
доступ через функцию \code{SLOT-VALUE}. \code{SLOT-VALUE} в качестве аргументов принимает
объект и имя слота и возвращает значение нужного слота в данном объекте.  Эта функция
может использоваться вместе с \code{SETF} для установки значений слота в объекте.

Класс также наследует спецификаторы слотов от своих суперклассов, так что набор слотов,
присутствующих в любом объекте, является объединением всех слотов, указанных в форме
\code{DEFCLASS} для класса, а также указанных для всех его суперклассов.

По минимуму, спецификатор слота указывает его имя, так что спецификатор может быть простым
именем.  Например, вы можете определить класс \code{bank-account} с двумя слотами~---
\code{customer-name} и \code{balance}, например, вот так:

\begin{lstlisting}
(defclass bank-account ()
  (customer-name
   balance))
\end{lstlisting}

Каждый экземпляр этого класса содержит два слота: один для хранения имени клиента, а
второй ~--- для хранения текущего баланса счёта.  Используя данное определение вы можете
создать новые объекты \code{bank-account} с помощью \code{MAKE-INSTANCE}.

\begin{verbatim}
  (make-instance 'bank-account) ==> #<BANK-ACCOUNT @ #x724b93ba>
\end{verbatim}

Аргументом \code{MAKE-INSTANCE} является имя класса, а возвращаемым значением~--- новый
объект.\footnote{В действительности, аргументом \code{MAKE-INSTANCE} может быть либо имя
  класса, или объект класса, возвращаемый функциями \code{CLASS-OF} или
  \code{FIND-CLASS}.}  Печатное представление объекта определяется обобщённой функцией
\code{PRINT-OBJECT}.  В этом случае, подходящим методом будет тот, который предоставляется
реализацией и специализированный для \code{STANDARD-OBJECT}.  Поскольку не каждый объект
может быть выведен таким образом, чтобы потом быть считанным назад, то метод печати для
\code{STANDARD-OBJECT} использует синтаксис \lstinline!#<>!, который заставит процедуру
чтения выдать ошибку, если он попытается прочитать его.  Оставшаяся часть представления
зависит от реализации, но обычно оно похоже на результат, приведённый выше, включая имя
класса и некоторое значение, например, адрес объекта в памяти.  В главе~\ref{ch:23} вы
увидите пример того, как определить метод для \code{PRINT-OBJECT} чтобы некоторые классы
можно было вывести в более информативной форме.

Используя данное определение \code{bank-account}, новые объекты будут создаваться со
слотами, которые не связаны со значениями.  Любая попытка получить значение для
несвязанного значения приведёт к выдаче ошибки, так что вы должны задать значение до того,
как вы будете считывать значения.

\begin{verbatim}
  (defparameter *account* (make-instance 'bank-account))  ==> *ACCOUNT*
  (setf (slot-value *account* 'customer-name) "John Doe") ==> "John Doe"
  (setf (slot-value *account* 'balance) 1000)             ==> 1000
\end{verbatim}

Теперь вы можете получать значения слотов.

\begin{verbatim}
  (slot-value *account* 'customer-name) ==> "John Doe"
  (slot-value *account* 'balance)       ==> 1000
\end{verbatim}

\section{Инициализация объекта}

Поскольку мы мало что можем сделать с объектом, который имеет пустые слоты, было бы хорошо
иметь возможность создавать объекты с инициализированными слотами.  Common Lisp
предоставляет три способа управления начальными значениями слотов.  Первые два требуют
добавления опций в спецификаторы слотов в \code{DEFCLASS}: с помощью опции \code{:initarg}
вы можете указать имя, которое потом будет использоваться как именованный параметр при
вызове \code{MAKE-INSTANCE} и переданное значение будет сохранено в слоте.  Вторая опция
~--- \code{:initform}, позволяет вам указать выражение на Lisp, которое будет использоваться
для вычисления значения, если при вызове \code{MAKE-INSTANCE} не был передан аргумент
\code{:initarg} .  В заключение, для полного контроля за инициализацией объекта, вы можете
определить метод для обобщённой функции \code{INITIALIZE-INSTANCE}, которую вызывает
\code{MAKE-INSTANCE}.\footnote{Другим способом установки значений слотов, является
  использование опции \code{:default-initargs} при объявлении \code{DEFCLASS}.  Эта опция
  используется для указания выражений, которые будут вычислены для нахождения аргументов
  для отдельных параметров инициализации, которые не получили значение при вызове
  \code{MAKE-INSTANCE}.  В текущий момент времени вам не нужно беспокоиться о
  \code{:default-initargs}.}

Спецификатор слота, который включает опции, такие как \code{:initarg} или
\code{:initform}, записывается как список, начинающийся с имени слота, за которым следуют
опции.  Например, если вы измените определение \code{bank-account} таким образом, чтобы
позволить передавать имя клиента и начальный баланс при вызове \code{MAKE-INSTANCE}, а
также чтобы установить для баланса начальное значение равное нулю, вы должны написать:

\begin{lstlisting}
(defclass bank-account ()
  ((customer-name
    :initarg :customer-name)
   (balance
    :initarg :balance
    :initform 0)))
\end{lstlisting}

Теперь вы можете одновременно создавать счёт и указывать значения слотов.

\begin{lstlisting}
(defparameter *account*
  (make-instance 'bank-account :customer-name "John Doe" :balance 1000))

  (slot-value *account* 'customer-name) ==> "John Doe"
  (slot-value *account* 'balance)       ==> 1000
\end{lstlisting}

Если вы не передадите аргумент \code{:balance} при вызове \code{MAKE-INSTANCE}, то вызов
\code{SLOT-VALUE} для слота \code{balance} будет получен вычислением формы, указанной
опцией \code{:initform}.  Но, если вы не передадите аргумент \code{:customer-name}, то
слот \code{customer-name} будет пустой, и попытка считывания значения из него, приведёт к
выдаче ошибки.

\begin{verbatim}
  (slot-value (make-instance 'bank-account) 'balance)       ==> 0
  (slot-value (make-instance 'bank-account) 'customer-name) ==> Ошибка (error)
\end{verbatim}

Если вы хотите убедиться, что имя клиента было задано при создании счёта, то вы можете
выдать ошибку в начальном выражении (\code{initform}), поскольку оно будет вычислено
только если начальное значение (\code{initarg}) не было задано.  Вы также можете
использовать начальные формы, которые создают разные значения при каждом запуске~---
начальное выражение вычисляется заново для каждого объекта.  Для эксперементирования с
этими возможностями, вы можете изменить спецификатор слота \code{customer-name} и добавить
новый слот, \code{account-number}, который инициализируется значением увеличивающегося
счётчика.

\begin{lstlisting}
(defvar *account-numbers* 0)

(defclass bank-account ()
  ((customer-name
    :initarg :customer-name
    :initform (error "Must supply a customer name."))
   (balance
    :initarg :balance
    :initform 0)
   (account-number
    :initform (incf *account-numbers*))))
\end{lstlisting}

В большинстве случаев, комбинации опций \code{:initarg} и \code{:initform} будет
достаточно для нормальной инициализации объекта.  Однако, хотя начальное выражение может
быть любым выражением Lisp, оно не имеет доступа к инициализируемому объекту, так что оно
не может инициализировать один слот, основываясь на значении другого.  Для выполнения
такой задачи вам необходимо определить метод для обобщённой функции
\code{INITIALIZE-INSTANCE}.

Основной метод \code{INITIALIZE-INSTANCE}, специализированный для \code{STANDARD-OBJECT}
берёт на себя заботу об инициализации слотов, основываясь на данных, заданных опциями
\code{:initarg} и \code{:initform}.  Поскольку вы не захотите вмешиваться в этот процесс,
то наиболее широко применяемым способом является определение метода \code{:after},
специализированного для вашего класса.\footnote{Добавление метода \code{:after} к
  \code{INITIALIZE-INSTANCE} является аналогом на Common Lisp определению конструктора в
  Java или C++, или методу \lstinline!__init__! в Python.}  Например, предположим, что вы
хотите добавить слот \code{account-type}, который должен быть установлен в значение
\code{:gold}, \code{:silver} или \code{:bronze}, основываясь на начальном балансе счёта.
Вы можете изменить определение класса на следующее, добавляя слот \code{account-type} без
каких либо опций:

\begin{lstlisting}
(defclass bank-account ()
  ((customer-name
    :initarg :customer-name
    :initform (error "Must supply a customer name."))
   (balance
    :initarg :balance
    :initform 0)
   (account-number
    :initform (incf *account-numbers*))
   account-type))
\end{lstlisting}

После этого вы можете определить метод \code{:after} для \code{INITIALIZE-INSTANCE},
который установит значение слота \code{account-type}, основываясь на значении, которое
было сохранено в слоте \code{balance}.\footnote{Одна из ошибок, которую вы могли сделать
  до того, как освоились со вспомогательными методами, является в определении метода для
  \code{INITIALIZE-INSTANCE}, но без квалификатора \code{:after}.  Если вы сделаете это,
  вы получите новый основной метод, который скроет метод, вызываемый по умолчанию.  Вы
  можете удалить ненужный основной метод с помощью функций \code{REMOVE-METHOD} и
  \code{FIND-METHOD}.  Некоторые среды разработки могут предоставлять графический
  интерфейс для выполнения данной задачи.

\begin{lstlisting}
(remove-method #'initialize-instance
  (find-method #'initialize-instance () (list (find-class 'bank-account)))
\end{lstlisting}
}

\begin{lstlisting}
(defmethod initialize-instance :after ((account bank-account) &key)
  (let ((balance (slot-value account 'balance)))
    (setf (slot-value account 'account-type)
          (cond
            ((>= balance 100000) :gold)
            ((>= balance 50000) :silver)
            (t :bronze)))))
\end{lstlisting}

Указание \lstinline!&key! в списке параметров требуется обязательно, чтобы сохранить
список параметров соответствующим списку параметров обобщённой функции~--- список
параметров, указанный для функции \code{INITIALIZE-INSTANCE} включает \lstinline!&key!
чтобы позволить отдельным методам передавать собственные именованные параметры, но при
этом, он не требует указания конкретных названий.  Таким образом, каждый метод должен
указывать \lstinline!&key!, даже если он не указывает ни одного именованного параметра.

С другой стороны, если метод \code{INITIALIZE-INSTANCE}, специализированный для
конкретного класса, указывает именованный параметр, то этот параметр становится допустимым
параметром для функции \code{MAKE-INSTANCE} при создании экземпляра данного класса.
Например, если банк иногда платит процент начального баланса в качестве премии при
открытии счёта, то вы можете реализовать эту функцию, используя метод
\code{INITIALIZE-INSTANCE}, который получает именованный аргумент, указывающий процент
премии, например вот так:

\begin{lstlisting}
(defmethod initialize-instance :after ((account bank-account)
                                       &key opening-bonus-percentage)
  (when opening-bonus-percentage
    (incf (slot-value account 'balance)
          (* (slot-value account 'balance) (/ opening-bonus-percentage 100)))))
\end{lstlisting}

Путём определения метода \code{INITIALIZE-INSTANCE}, вы делаете
\code{:opening-bonus-percentage} допустимым аргументом функции \code{MAKE-INSTANCE} при
создании объекта \code{bank-account}.

\begin{verbatim}
  CL-USER> (defparameter *acct* (make-instance
                                  'bank-account
                                   :customer-name "Sally Sue"
                                   :balance 1000
                                   :opening-bonus-percentage 5))
  *ACCT*
  CL-USER> (slot-value *acct* 'balance)
  1050
\end{verbatim}

\section{Функции доступа}

\code{MAKE-INSTANCE} и \code{SLOT-VALUE} дают вам возможности для создания и работы с
экземплярами ваших классов.  Все остальные операции могут быть реализованы в терминах этих
двух функций.  Однако, как знает всякий, знакомый с принципами правильного
объектно-ориентированного программирования, прямой доступ к слотам (полям или
переменным-членам) объекта может привести к получению уязвимого кода.  Проблема
заключается в том, что прямой доступ к слотам делает ваш код слишком связанным с
конкретной структурой классов.  Например, предположим, что вы решили изменить определение
\code{bank-account} таким образом, что вместо хранения текущего баланса в виде числа, вы
храните его в виде списка списаний и помещений денег на счёт, вместе с датами этих
операций.  Код, который имеет прямой доступ к слоту \code{balance} скорее всего будет
сломан, если вы измените определение класса, удалив слот или храня список в данном
слоте. С другой стороны, если вы определить функцию \code{balance}, которая осуществляет
доступ к слоту, то вы можете позже переопределить её, чтобы сохранить её поведение, даже
если изменится внутреннее представление данных.  И код, который использует такую функцию
будет продолжать нормально работать не требуя внесения изменений.

Другим преимуществом использования функций доступа вместо прямого доступа к слотам через
\code{SLOT-VALUE} является то, что их использование позволяет вам ограничить возможность
внешней модификации слота.\footnote{Конечно, предоставление функции доступа в
  действительности не ограничивает ничего, поскольку сторонний код все равно может
  использовать \code{SLOT-VALUE} для прямого доступа к слотам. Common Lisp не
  предоставляет строгой инкапсуляции слотов, как это делают C++ и Java; однако, если автор
  класса предоставляет функции доступа и вы игнорируете их, вместо этого используя
  \code{SLOT-VALUE}, то вы должны лучше знать, что вы делаете.  Кроме этого, имеется
  возможность использования пакетной системы, которую я буду обсуждать в
  главе~\ref{ch:21}, чтобы ограничить прямой доступ к некоторым слотам путём отсутствия
экспорта имён слотов.} Для пользователей класса \code{bank-account} может быть удобным
использование функций доступа для получения текущего баланса, но вы можете захотеть, чтобы
все изменения баланса производились через другие предоставляемые вами функции, такие как
\code{deposit} и \code{withdraw}.  Если клиент знает, что он сможет работать с объектами
только через определённый набор функций, то вы можете предоставить ему функцию
\code{balance}, но сделать так, чтобы для неё нельзя было выполнить \code{SETF}, чтобы
баланс был доступен только для чтения.

В заключение, использование функций доступа делает ваш код более аккуратным, поскольку вы
избегаете использования множества менее понятных функций \code{SLOT-VALUE}.

Определение функции, которая читает содержимое слота \code{balance} является тривиальным.

\begin{lstlisting}
(defun balance (account)
  (slot-value account 'balance))
\end{lstlisting}

Однако, если вы знаете, что вы будете определять подклассы для \code{bank-account}, то
может быть хорошей идеей определение \code{balance} в качестве обобщённой функции.  Таким
образом вы можете определить разные методы для \code{balance} для некоторых подклассов,
или расширить её возможности с помощью вспомогательных методов. Так что вместо предыдущего
примера можете написать следующее:

\begin{lstlisting}
(defgeneric balance (account))

(defmethod balance ((account bank-account))
  (slot-value account 'balance))
\end{lstlisting}

Как я только что обсуждал, вы не хотите, чтобы пользователь имел возможность устанавливать
баланс напрямую, но для других слотов, таких как \code{customer-name}, вы также можете
захотеть предоставить функцию для установки их значений.  Наиболее понятным способом будет
определение такой функции как \code{SETF}-функции.

\code{SETF}-функция является способом расширения функциональности \code{SETF}, определяя
новый вид места (place), для которого известно как устанавливать его значение.  Имя
\code{SETF}-функции является списком из двух элементов, где первый элемент является
символом \code{setf}, а второй~--- другим символом, обычно именем функции, которая
используется для доступа к месту, значение которого будет устанавливать функция
\code{SETF}.  \code{SETF}-функция может получать любое количество аргументов, но первым
аргументом всегда является значение, присваиваемое выбранному месту.\footnote{Одним из
  следствий определения \code{SETF}-функции (например, \code{(setf foo)}) является то, что
  если вы также определяете соответствующую функцию доступа, в нашем случае это
  \code{foo}, то вы можете использовать все макросы изменяющие значения, которые построены
  на основе \code{SETF}, такие как \code{INCF}, \code{DECF}, \code{PUSH} и \code{POP}, для
  нового вида места.}  Например, вы можете определить \code{SETF}-функцию для установки
значения слота \code{customer-name} в классе \code{bank-account} следующим образом:

\begin{lstlisting}
(defun (setf customer-name) (name account)
  (setf (slot-value account 'customer-name) name))
\end{lstlisting}

После вычисления этого определения, выражения, подобные этому:

\begin{lstlisting}
(setf (customer-name my-account) "Sally Sue")
\end{lstlisting}

будут компилироваться как вызов \code{SETF}-функции, которую вы только что определили с
значением <<Sally Sue>> в качестве первого аргумента, и значением \code{my-account} в
качестве второго аргумента.

Конечно, также как с функциями чтения, вы вероятно захотите, чтобы ваша
\code{SETF}-функция была обобщённой, так что вы должны её определить примерно так:

\begin{lstlisting}
(defgeneric (setf customer-name) (value account))

(defmethod (setf customer-name) (value (account bank-account))
  (setf (slot-value account 'customer-name) value))
\end{lstlisting}

И конечно, вы также можете определить функцию чтения для \code{customer-name}.

\begin{lstlisting}
(defgeneric customer-name (account))

(defmethod customer-name ((account bank-account))
  (slot-value account 'customer-name))
\end{lstlisting}

Это позволит вам писать следующим образом:

\begin{verbatim}
  (setf (customer-name *account*) "Sally Sue") ==> "Sally Sue"

  (customer-name *account*)                    ==> "Sally Sue"
\end{verbatim}

Нет ничего сложного в написании этих функций доступа, но написание этих функций вручную
просто не соответствует The Lisp Way.  Так что \code{DEFCLASS} поддерживает три опции для
слотов, которые позволяют вам автоматически создавать функции чтения и записи значений
отдельных слотов.

Опция \code{:reader} указывает имя, которое будет использоваться как имя обобщённой
функции, которая принимает объект в качестве своего единственного аргумента.  Когда
вычисляется \code{DEFCLASS}, то создаётся соответствующая обобщённая функция (если она ещё
не определена конечно).  После этого для данной обобщённой функции создаётся метод,
специализированный для нового класса и возвращающий значение слота.  Имя функции может
быть любым, но обычно используют то же самое имя, что и имя самого слота.  Так что вместо
явного задания обобщённой функции \code{balance} и метода для неё, как это было показано
раньше, вы можете просто изменить спецификатор слота \code{balance} в определении класса
\code{bank-account} на следующее:

\begin{lstlisting}
(balance
 :initarg :balance
 :initform 0
 :reader balance)
\end{lstlisting}

Опция \code{:writer} используется для создания обобщённой функции и метода для установки
значения слота.  Создаваемая функция и метод следуют требованиям для \code{SETF}-функции,
получая новое значение как первый аргумент, и возвращая его в качестве результата, так что
вы можете определить \code{SETF}-функцию задавая имя, такое как \code{(setf
  customer-name)}.  Например, вы можете определить методы чтения и записи для слота
\code{customer-name}, просто изменяя спецификатор слота на следующее определение:

\begin{lstlisting}
(customer-name
 :initarg :customer-name
 :initform (error "Must supply a customer name.")
 :reader customer-name
 :writer (setf customer-name))
\end{lstlisting}

Поскольку достаточно часто требуется определение обеих функций доступа, то \code{DEFCLASS}
также имеет опцию \code{:accessor}, которая создаёт и функцию чтения, и соответствующую
\code{SETF}-функцию.  Так что вместо предыдущего примера можно написать следующим образом:

\begin{lstlisting}
(customer-name
 :initarg :customer-name
 :initform (error "Must supply a customer name.")
 :accessor customer-name)
\end{lstlisting}

В заключение, опишу ещё одну опцию, о которой вы должны знать: опция \code{:documentation}
позволяет вам задать строку, которая описывает данный слот.  Собирая все в кучу и добавляя
методы чтения для слотов \code{account-number} и \code{account-type}, определение
\code{DEFCLASS} для класса \code{bank-account} будет выглядеть примерно так:

\begin{lstlisting}
(defclass bank-account ()
  ((customer-name
    :initarg :customer-name
    :initform (error "Must supply a customer name.")
    :accessor customer-name
    :documentation "Customer's name")
   (balance
    :initarg :balance
    :initform 0
    :reader balance
    :documentation "Current account balance")
   (account-number
    :initform (incf *account-numbers*)
    :reader account-number
    :documentation "Account number, unique within a bank.")
   (account-type
    :reader account-type
    :documentation "Type of account, one of :gold, :silver, or :bronze.")))
\end{lstlisting}

\section{\code{WITH-SLOTS} и \code{WITH-ACCESSORS}}

В то время как функции доступа делают ваш код более лёгким для сопровождения, они все ещё
достаточно многословны.  И конечно будут моменты, когда вы будете писать методы, которые
реализуют низкоуровневое поведение класса, так что вы можете осознанно осуществлять доступ
к слотам для установки значений слотов, для которых нет функций записи, или для получения
значений из слотов, без использования функций чтения.

Это как раз тот случай, для которого и предназначен макрос \code{SLOT-VALUE}; однако, он
также достаточно многословен.  Если функция или метод осуществляют доступ к одному и тому
же слоту несколько раз, то исходный код будет засорён вызовами функций доступа и
\code{SLOT-VALUE}.  Например, даже достаточно простой метод, такой как следующий пример,
который вычисляет пеню для \code{bank-account} если баланс снижается ниже некоторого
минимума, будет засорён вызовами \code{balance} и \code{SLOT-VALUE}:

\begin{lstlisting}
(defmethod assess-low-balance-penalty ((account bank-account))
  (when (< (balance account) *minimum-balance*)
    (decf (slot-value account 'balance) (* (balance account) .01))))
\end{lstlisting}

И если вы решите, что вы хотите осуществлять прямой доступ к слоту для того, чтобы
избежать вызова вспомогательных методов, то ваш код будет ещё больше замусоренным.

\begin{lstlisting}
(defmethod assess-low-balance-penalty ((account bank-account))
  (when (< (slot-value account 'balance) *minimum-balance*)
    (decf (slot-value account 'balance) (* (slot-value account 'balance) .01))))
\end{lstlisting}

Два стандартных макроса~--- \code{WITH-SLOTS} и \code{WITH-ACCESSORS}, могут помочь
избавиться от этого мусора.  Оба макроса создают блок кода, в которых могут использоваться
простые имена переменных для обращения к слотам определённого объекта.  \code{WITH-SLOTS}
предоставляет прямой доступ к слота, также как при использовании \code{SLOT-VALUE}, в то
время как \code{WITH-ACCESSORS} предоставляет сокращённый способ вызова функций доступа.

Базовая форма  \code{WITH-SLOTS} выглядит следующим образом:

\begin{lstlisting}
(with-slots (slot*) instance-form
  body-form*)
\end{lstlisting}

Каждый элемент списка \code{slot} может быть либо именем слота,которое также является
именем переменной, либо списком из двух элементов, где первый аргумент является именем,
которое будет использоваться как переменная, а второй~--- именем соответствующего слота.
Выражение \code{instance-form} вычисляется один раз для получения объекта, к слотам
которого будет производиться доступ.  Внутри тела макроса, каждое вхождение имени
переменной преобразуется в вызов \code{SLOT-VALUE} с использованием объекта и имени слота
в качестве аргументов.\footnote{Имена <<переменных>>, предоставляемые \code{WITH-SLOTS} и
  \code{WITH-ACCESSORS} не являются настоящими переменными; они реализуются специальным
  видом макросов, называемых символьными макросами, которые позволяют простому имени
  преобразовываться в произвольный код.  Символьные макросы были введены в язык для
  поддержки \code{WITH-SLOTS} и \code{WITH-ACCESSORS}, но вы также можете использовать их
  для своих целей.  Я их более подробно опишу в главе~\ref{ch:20}.}  Таким образом, вы можете
  переписать \code{assess-low-balance-penalty} вот так:

\begin{lstlisting}
(defmethod assess-low-balance-penalty ((account bank-account))
  (with-slots (balance) account
    (when (< balance *minimum-balance*)
      (decf balance (* balance .01)))))
\end{lstlisting}

или используя списочную запись, вот так:

\begin{lstlisting}
(defmethod assess-low-balance-penalty ((account bank-account))
  (with-slots ((bal balance)) account
    (when (< bal *minimum-balance*)
      (decf bal (* bal .01)))))
\end{lstlisting}

Если вы определили \code{balance} с использованием опции \code{:accessor}, а не
\code{:reader}, то вы также можете использовать макрос \code{WITH-ACCESSORS}.  Форма
\code{WITH-ACCESSORS} такая же как \code{WITH-SLOTS} за тем исключением, что каждый
элемент списка слотов является списком из двух элементов, содержащих имя переменной и имя
функции доступа.  Внутри тела \code{WITH-ACCESSORS}, ссылка на одну из переменных,
аналогична вызову соответствующей функции доступа.  Если функция доступа разрешает
выполнение \code{SETF}, то тоже самое возможно и для переменной.

\begin{lstlisting}
(defmethod assess-low-balance-penalty ((account bank-account))
  (with-accessors ((balance balance)) account
    (when (< balance *minimum-balance*)
      (decf balance (* balance .01)))))
\end{lstlisting}

Первое вхождение \code{balance} является именем переменной, а второе~--- именем функции
доступа; они не обязательно должны быть одинаковыми.  Например, вы можете написать метод
для слияния двух счетов, используя два вызова \code{WITH-ACCESSORS}, для каждого из
счетов.

\begin{lstlisting}
(defmethod merge-accounts ((account1 bank-account) (account2 bank-account))
  (with-accessors ((balance1 balance)) account1
    (with-accessors ((balance2 balance)) account2
      (incf balance1 balance2)
      (setf balance2 0))))
\end{lstlisting}

Выбор между использованием \code{WITH-SLOTS} и \code{WITH-ACCESSORS} примерно таков, как и
выбор между использованием \code{SLOT-VALUE} и функций доступа: низкоуровневый код,
которые обеспечивает основную функциональность класса, может использовать
\code{SLOT-VALUE} или \code{WITH-SLOTS} для работы со слотами напрямую, если функции
доступа не поддерживают нужный стиль работы, или если хочется явно избежать использования
вспомогательных методов, которые могут быть определены для функций доступа.  Но в общем вы
должны использовать функции доступа или \code{WITH-ACCESSORS}, если только у вас не
имеются конкретные причины не делать этого.

\section{Слоты, выделяемые для классов}

Заключительной опцией, которую вам необходимо знать, является опция \code{:allocation}.
Значением опции \code{:allocation} может быть либо \code{:instance}, либо \code{:class}, и
по умолчанию оно равно \code{:instance}, если оно не было явно указано.  Когда слот имеет
значение опции равное \code{:class}, то слот имеет только одно значение, которое
сохраняется внутри класса и используется всеми экземплярами.

Однако доступ к слотам со значением \code{:class} производится также как и для слотов со
значением \code{:instance}~--- доступ производится с помощью \code{SLOT-VALUE} или функции
доступа, что значит, что вы можете получить доступ только через экземпляр класса, хотя это
значение не хранится в этом экземпляре.  Опции \code{:initform} и \code{:initarg} имеют
точно такой же эффект, за тем исключением, что начальное выражение вычисляется один раз,
при определении класса, а не при создании экземпляра.  С другой стороны, передача
начальных аргументов \code{MAKE-INSTANCE} установит значение, затрагивая все экземпляры
данного класса.

Поскольку вы не можете получить слот, выделенный для класса, не имея экземпляра класса, то
такие слоты не являются полным аналогам статическим членам в таких языках как Java, C++ и
Python.\footnote{Meta Object Protocol (MOP), который не является частью стандарта языка,
  но поддерживается большинством реализаций Common Lisp, предоставляет функцию
  \code{class-prototype}, которая возвращает экземпляр класса, который может
  использоваться для доступа к слотам, выделенным для класса.  Если вы используете
  реализацию, которая поддерживает MOP и вы переносите программу с другого языка, который
  часто использует статические переменные, то эта функция облегчит этот процесс.  Но все
  не настолько однозначно.}  В значительной степени, слоты выделенные для класса в
основном используются для уменьшения потребляемой памяти; если вы создаёте много
экземпляров класса и они все имеют ссылку на один и тот же объект (например, список
разделяемых ресурсов), то вы можете сократить использование памяти путём объявления такого
слота, выделяемым для класса, а не для экземпляра.

\section{Слоты и наследование}

Как обсуждалось в предыдущей главе, классы наследуют поведение от своих суперклассов
благодаря механизмам обобщённых функции~--- метод специализированный для класса \code{A}
также применим не только к экземплярам класса \code{A}, но также и к экземплярам классов,
унаследованных от \code{A}.  Классы также наследуют от своих суперклассов слоты, но этот
механизм немного отличается.

В Common Lisp конкретный объект может иметь только один слот с определённым именем.
Однако возможно, что в иерархии наследования класса несколько классов будут иметь слоты с
одним и тем же именем.  Это может случиться либо потому, что подкласс включает
спецификатор слота с тем же именем, что и слот указанный в суперклассе, либо потому, что
несколько суперклассов имеют слоты с одним и тем же именем.

Common Lisp решает эту проблему путём слияния всех спецификаторов с одним и тем же именем
из нового класса и всех его суперклассов для создания отдельных спецификаторов для каждого
уникального имени слота.  При слиянии спецификатор, разные опции спецификаторов слотов
рассматриваются по разному.  Например, поскольку слот может иметь только одно значение по
умолчанию, то если несколько классов указывают опцию \code{:initform}, то новый класс
будет использовать эту опцию из наиболее специализированного класса.  Это позволяет
подклассам указывать собственные значение по умолчанию, а не те, которые были
унаследованы.

С другой стороны, опции \code{:initargs} не должны быть взаимоисключающими~--- каждая опция
\code{:initarg} создаёт именованный параметр, который может быть использован для
инициализации слота; множественные параметры не приводят к конфликту, так что новый
спецификатор слота будет содержать все опции \code{:initargs}. Вызывающие
\code{MAKE-INSTANCE} могут использовать любое из имён, указанных в \code{:initargs} для
инициализации слота. Если вызывающий указывает несколько именованных аргументов, которые
инициализируют один и тот же слот, то используется то, которое стоит левее всех остальных
в списке аргументов \code{MAKE-INSTANCE}.

Унаследованные опции \code{:reader}, \code{:writer} и \code{:accessor} не включаются в
новый спецификатор слота, поскольку методы, созданные при объявлении суперкласса будут
автоматически применяться к новому классу.  Однако новый класс может создать свои
собственные функции доступа, путём объявления собственных опций \code{:reader},
\code{:writer} или \code{:accessor}.

И в заключение, опция \code{:allocation}, подобно \code{:initform}, определяется наиболее
специализированным классом, определяющим данный слот.  Таким образом, возможно сделать
так, что экземпляры одного класса будут использовать слот с опцией \code{:class}, а
экземпляры его подклассов могут иметь свои собственные значения опции \code{:instance} для
слота с тем же именем.  А их подклассы, в свою очередь, могут переопределить этот слот с
опцией \code{:class}, так что все экземпляры данного класса снова будут делить между собой
единственный экземпляр слота.  В последнем случае, слот, разделяемый экземплярами
под-подклассов отличается от слота, разделяемого оригинальным суперклассом.

Например, у вас имеются следующие классы:

\begin{lstlisting}
(defclass foo ()
  ((a :initarg :a :initform "A" :accessor a)
   (b :initarg :b :initform "B" :accessor b)))

(defclass bar (foo)
  ((a :initform (error "Must supply a value for a"))
   (b :initarg :the-b :accessor the-b :allocation :class)))
\end{lstlisting}

При создании экземпляра класса \code{bar}, вы можете использовать унаследованный начальный
аргумент \code{:a} для указания значения для слота \code{a} и, в действительности, должны
сделать это для того, чтобы избежать ошибок, поскольку опция \code{:initform} определённая
\code{bar} замещает опцию, унаследованную от \code{foo}. Для инициализации слота \code{b},
вы можете использовать либо унаследованный аргумент \code{:b}, либо новый аргумент
\code{:the-b}.  Однако, поскольку для слота \code{b} в определении \code{bar} указана
опция \code{:allocation}, то указанное значение будет храниться в слоте, используемом
всеми экземплярами \code{bar}. Доступ к этому слоту может быть может быть осуществлён либо
с помощью метода обобщённой функции \code{b}, специализированного для \code{foo}, либо с
помощью нового метода обобщённой функции \code{the-b}, который специализирован для
\code{bar}.  Для доступа к слоту \code{a} классов \code{foo} или \code{bar}, вы продолжите
использовать обобщённую функцию \code{a}.

Обычно, слияние определений слотов происходит достаточно гладко.  Однако важно помнить,
что при использовании множественного наследования два не относящихся друг к другу слота,
имеющих одно и тоже имя, в новом классе будут слиты в один слот.  Так что методы,
специализированные для разных классов могут работать с одним и тем же слотом, когда они
будут применяться к классу, унаследованному от этих классов.  На практике это не
доставляет особых проблем, поскольку, как вы увидите в главе~\ref{ch:21}, вы можете
использовать пакетную систему для того, чтобы избежать коллизий между именами в коде.

\section{Множественное наследование}
\label{sec:17-multi-inheritance}

Все классы, которые вы до сих пор видели имели только один суперкласс. Common Lisp также
поддерживает множественное наследование~--- класс может иметь несколько прямых
суперклассов, наследуя соответствующие методы и спецификаторы слотов из всех этих классов.

Множественное наследование не вносит кардинальных изменений в механизмы наследования,
которые я уже обсуждал~--- каждый класс определённый пользователем уже имеет несколько
суперклассов, поскольку они все наследуются от \code{STANDARD-OBJECT}, который унаследован
от \code{T}, так что по крайней мере имеется два суперкласса.  Затруднение, которое вносит
множественное наследование заключается в том, что класс может иметь более одного
непосредственного суперкласса.  Это усложняет понятие специфичности класса, которое
используется при построении эффективных методов для обобщённых функции и при слиянии
спецификаторов слотов.

Так что, если бы классы могли иметь только один непосредственный суперкласс, то
упорядочение классов по специфичности будет тривиальным~--- класс и все его суперклассы
могут быть выстроены в линию начиная с самого класса, за которым следует один прямой
суперкласс, за которым следует его суперкласс, и так далее, до класса \code{T}.  Но когда
класс имеет несколько непосредственных суперклассов, то эти классы обычно не связаны друг
с другом~--- конечно, если один класс был подклассом другого, вам не нужно наследовать
класс от обоих.  В этом случае, правила по которому подклассы более специфичны чем
суперклассы недостаточно для упорядочения всех суперклассов.  Так что Common Lisp
использует второе правило, которое сортирует не относящиеся друг к другу суперклассы по
порядку в котором они перечислены в определении непосредственных суперклассов в
\code{DEFCLASS}~--- классы, указанные в списке первыми, считаются более специфичными, чем
классы, указанные в списке последними.  Это правило считается достаточно произвольным, но
оно позволяет каждому классу иметь линейный список следования классов, который может
использоваться для определения того, какой из суперклассов будет считаться более
специфичным чем другой.  Однако заметьте, что нет глобального упорядочения классов~---
каждый класс имеет собственный список следования классов, и одни и те же классы могут
стоять на разных позициях в списках списках следования разных классов.

Для того, чтобы увидеть как это работает, давайте добавим новый класс к нашему банковскому
приложению: \code{money-market-account}.  Этот счёт объединяет в себе характеристики
чекового (\code{checking-account}) и сберегательного (\code{savings-account}) счетов:
клиент может выписывать чеки, но кроме того он получает проценты.  Вы можете определить
его следующим образом:

\begin{lstlisting}
(defclass money-market-account (checking-account savings-account) ())
\end{lstlisting}

Список следования класса \code{money-market-account} будет следующим:

\begin{lstlisting}
(money-market-account
 checking-account
 savings-account
 bank-account
 standard-object
 t)
\end{lstlisting}

Заметьте, как список удовлетворяет обоим правилам: каждый класс появляется раньше своих
суперклассов, а \code{checking-account} и \code{savings-account} располагаются в порядке,
указанном в \code{DEFCLASS}.

Этот класс не определяет своих собственных слотов, но унаследует слоты от обоих
суперклассов, включая слоты, которые те унаследовали от своих суперклассов.  Аналогичным
образом, все методы, которые применимы к любому из классов в списке следования, также
будут применимы к объекту \code{money-market-account}.  Поскольку все спецификаторы
одинаковых слотов объединяются, то не имеет значения, что \code{money-market-account}
дважды наследует одни и те же слоты из \code{bank-account}.\footnote{Другими словами,
  Common Lisp не страдает от проблемы наследования (diamond inheritance problem), которая
  имеется в C++.  В C++, когда один класс наследуется от двух классов, которые оба
  наследуют переменную от общего суперкласса, то он наследует эту переменную дважды, что
  ведёт к беспорядку.}

Множественное наследование наиболее просто понять когда суперклассы предоставляют
совершенно независимые наборы слотов и методов.  Например, \code{money-market-account}
унаследует слоты и поведение по работе с чеками от \code{checking-account}, а слоты и
поведение по вычислению процентов~--- от \code{savings-account}.  Вам не нужно беспокоиться
о списке следования класса для методов и слотов, унаследованных только от одного или
другого суперкласса.

Однако, также возможно унаследовать методы для одних и тех же обобщённых функций от
различных суперклассов.  В этом случае, в игру включается список список следования
классов.  Например, предположим, что банковское приложение определяет обобщённую функцию
\code{print-statement}, которая используется для генерации месячных отчётов.  Вероятно,
что уже будут определены методы \code{print-statement} специализированные для.
\code{checking-account} и \code{savings-account}.  Оба этих метода будут применимы для
экземпляров класса \code{money-market-account}, но тот, который специализирован для
\code{checking-account} будет считаться более специфичным, чем специализированный для
\code{savings-account}, поскольку \code{checking-account} имеет больший приоритет перед
\code{savings-account} в списке следования классов \code{money-market-account}.

Предполагается, что унаследованные методы являются основными методами, и вы не определяли
других методов, специализированных для \code{checking-account}, которые будут
использоваться, если вы выполните \code{print-statement} для \code{money-market-account}.
Однако, это не обязательно даст вам то поведение, которое вы хотите, поскольку вы хотите
чтобы отчёт для нового счёта содержал элементы из отчётов по чековому и сберегательному
счетов.

Вы можете изменить поведение \code{print-statement} для \code{money-market-accounts}
несколькими способами.  Непосредственным способом является определение основного метода,
специализированного для \code{money-market-account}.  Это даст вам полный контроль за
поведением, но вероятно потребует написания кода для опций, которые я буду вскоре
обсуждать.  Проблема заключается в том, что хотя вы можете использовать
\code{CALL-NEXT-METHOD} для передачи управления <<вверх>>, следующему методу, а именно,
специализированному для \code{checking-account}, но не существует способа вызвать
конкретный менее специфичный метод, например, специализированный для
\code{savings-account}.  Так что если вы хотите иметь возможность использования кода,
который создаёт часть отчёта, специфичную для \code{savings-account}, то вам нужно разбить
этот код на отдельные функции, которые вы сможете вызвать напрямую из методов
\code{print-statement} классов \code{money-market-account} и \code{savings-account}.

Другой возможностью является написание основных методов всех трёх классов так, чтобы они
вызывали \code{CALL-NEXT-METHOD}.  Тогда метод, специализированный для
\code{money-market-account} будет использовать \code{CALL-NEXT-METHOD} для вызова метода,
специализированного для \code{checking-account}.  Затем, этот метод вызовет
\code{CALL-NEXT-METHOD}, что приведёт к запуску метода для \code{savings-account},
поскольку он будет следующим наиболее специфичным методом в списке следования классов для
\code{money-market-account}.

Конечно, если вы не хотите полагаться на соглашения о стиле кодирования (что каждый метод
будет вызывать \code{CALL-NEXT-METHOD}) чтобы убедиться, что все применимые методы будут
вызваны в некоторый момент времени, вы должны подумать об использовании вспомогательных
методов.  В этом случае, вместо определения основного метода \code{print-statement} для
\code{checking-account} и \code{savings-account}, вы можете определить их как методы
\code{:after}, оставляя один основной метод для \code{bank-account}.  Так что
\code{print-statement}, вызванный для \code{money-market-account}, выдаст базовую
информацию о счёте, которая будет выведена основным методом, специализированным для
\code{bank-account}, за которым следуют дополнительные детали, выведенные методами
\code{:after} специализированными для \code{savings-account} и \code{checking-account}. И
если вы хотите добавить детали, специфичные для \code{money-market-accounts}, вы можете
определить метод \code{:after}, специализированный для \code{money-market-account},
который будет выполнен последним.

Преимуществом использования вспомогательных методов является то, что становится понятным
какие из методов является ответственным за реализацию обобщённой функции, и какие из них
вносят дополнительные детали в работу функции.  Недостатком этого подходя является то, что
вы не получаете точного контроля за порядком, в котором будут выполняться вспомогательные
методы~--- если вы хотите, чтобы часть отчёта, приготовленного для \code{checking-account}
печаталась перед частью \code{savings-account}, то вы должны изменить порядок в котором
\code{money-market-account} наследуются от этих классов.  Но это достаточно трагическое
изменение, которое затрагивает другие методы и унаследованные слоты.  В общем, если вы
обнаружите, что рассматриваете изменение списка непосредственных суперклассов как способ
тонкой настройки поведения специфических методов, то вы скорее всего должны сделать шаг
назад и заново обдумать ваш подход.

С другой стороны, если вы не заботитесь о порядке наследования, но хотите, чтобы он был
последовательным для разных обобщённых функций, то использование вспомогательных методов
может быть одним из методов.  Например, если в добавление к \code{print-statement} вы
имеете функцию \code{print-detailed-statement}, то вы можете реализовать обе функции
используя методы\code{:after} для разных подклассов \code{bank-account}, и порядок частей
и для основного и детального отчёта будет одинаков.


\section{Правильный объектно-ориентированный дизайн}

Это все о главных возможностях объектной системы Common Lisp.  Если у вас имеется большой
опыт объектно-ориентированного программирования, вы вероятно увидите как возможности
Common Lisp могут быть использованы для реализации правильного объектно-ориентированного
дизайна.  Однако, если у вас небольшой опыт объектно-ориентированного программирования, то
вам понадобиться провести некоторое время чтобы освоиться с объектно-ориентированным
мышлением.  К сожалению это достаточно большой раздел, находящийся за пределами данной
книги.  Или, как указано в справочной странице по объектной системе Perl, <<Теперь, вам
нужно лишь выйти и купить книгу о методологии объектно-ориентированного дизайна, и
провести с нею следующие шесть месяцев>>.  Или вы можете продолжить чтение до практических
глав, далее в этой книге, где вы увидите несколько примеров того, как эти возможности
используются на практике.  Однако сейчас, вы готовы к тому, чтобы взять перерыв и перейти
от теории объектно-ориентированного программирования к другой теме~--- как можно полезно
использовать мощную, но немного загадочную функцию Common Lisp~--- \code{FORMAT}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
