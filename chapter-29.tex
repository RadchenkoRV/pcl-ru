\chapter{Практика. Браузер MP3 файлов}
\label{ch:29}

Заключительным шагом в построении приложения для потокового вещания MP3 является
разработка Web-интерфейса, который позволит пользователям найти песни, которые они хотят
слушать, и добавлять их в списки песен которые будут использоваться сервером Shoutcast при
получении запроса от MP3-клиента пользователя.  Для этого компонента приложения вы
соберёте вместе несколько компонентов, разработанных в предыдущих главах: базу данных MP3,
макрос \code{define-url-function} из главы~\ref{ch:26} и, конечно, сам сервер Shoutcast.

\section{Списки песен}

Основная идея интерфейса заключается в том, что каждый MP3-клиент, который подключается к
серверу Shoutcast, получает отдельный список песен, который служит источником песен для
сервера Shoutcast.  Список песен также реализует дополнительные функции, не нужные серверу
Shoutcast: используя Web-интерфейс, пользователь сможет добавлять песни в список, удалять
песни из него, или изменять порядок проигрывания путём сортировки и перемешивания.

Вы можете определить класс для представления списка песен следующим образом:

\begin{lstlisting}
(defclass playlist ()
  ((id           :accessor id           :initarg :id)
   (songs-table  :accessor songs-table  :initform (make-playlist-table))
   (current-song :accessor current-song :initform *empty-playlist-song*)
   (current-idx  :accessor current-idx  :initform 0)
   (ordering     :accessor ordering     :initform :album)
   (shuffle      :accessor shuffle      :initform :none)
   (repeat       :accessor repeat       :initform :none)
   (user-agent   :accessor user-agent   :initform "Unknown")
   (lock         :reader   lock         :initform (make-process-lock))))
\end{lstlisting}

Идентификатор списка песен (\code{id}) является ключом, который вы извлекаете из объекта
\code{request}, переданного \code{find-song-source} когда происходит поиск списка песен.
Вам не нужно сохранять его в объекте \code{playlist}, но это сделает отладку более
простой, если вы сможете для произвольного объекта \code{playlist} определить его
идентификатор.

Самым главным объектом \code{playlist} является слот \code{songs-table}, который будет
хранить объект \code{table}.  Схема этого объекта будет той же самой, что и схема для
основной базы данных MP3.  Функция \code{make-playlist-table}, которую вы используете для
инициализации \code{songs-table}, очень проста:

\begin{lstlisting}
(defun make-playlist-table ()
  (make-instance 'table :schema *mp3-schema*))
\end{lstlisting}

%TODO Start of block

Пакет

Вы можете определить пакет для кода данной главы с помощью следующего определения
\code{DEFPACKAGE}:

\begin{lstlisting}
(defpackage :com.gigamonkeys.mp3-browser
  (:use :common-lisp
        :net.aserve
        :com.gigamonkeys.html
        :com.gigamonkeys.shoutcast
        :com.gigamonkeys.url-function
        :com.gigamonkeys.mp3-database
        :com.gigamonkeys.id3v2)
  (:import-from :acl-socket
                :ipaddr-to-dotted
                :remote-host)
  (:import-from :multiprocessing
                :make-process-lock
                :with-process-lock)
  (:export :start-mp3-browser))
\end{lstlisting}

%TODO End of block

Поскольку это высокоуровневое приложение, оно использует очень много низкоуровневых
пакетов.  Оно также импортирует три символа из пакета \code{ACL-SOCKET} и два из пакета
\code{MULTIPROCESSING}, поскольку нам необходимы только эти пять символов, и не нужны
остальные 139 символово, экспортируемые из этих пакетов.

Из-за сохранения списка песен в виде таблицы, вы можете использовать функции работы с
базами данных из главы~\ref{ch:27} для работы со списком песен: вы можете добавлять данные
в список песен с помощью \code{insert-row}, удалять песни с помощью \code{delete-rows}, и
изменять порядок проигрывания с помощью \code{sort-rows} и \code{shuffle-table}.

Слоты \code{current-song} и \code{current-idx} используются для хранения информации о том,
какая песня сейчас проигрывается: \code{current-song}~--- это объект \code{song}, в то
время как \code{current-idx} является индексом строки в \code{songs-table}, относящейся к
текущей песне. В разделе "Изменение списка песен" вы увидите как сделать так, чтобы
\code{current-song} обновлялась когда изменяется \code{current-idx}.

Слоты \code{ordering} и \code{shuffle} хранят информацию о том, как песни в
\code{songs-table} должны быть упорядочены.  Слот \code{ordering} хранит ключевое слово,
которое описывает то, как таблица \code{songs-table} должна быть отсортирована, когда она
не перемешана. Допустимыми значениями являются \code{:genre}, \code{:artist},
\code{:album} и \code{:song}.  Слот \code{shuffle} содержит одно из ключевых слов
\code{:none}, \code{:song} или \code{:album}, которые определяют как песни в
\code{songs-table} будут перемешаны, если это нужно.

Слот \code{repeat} также содержит одно ключевых слов \code{:none}, \code{:song} или
\code{:all}, которые указывают режим повторения песен в списке проигрывания.  Если
\code{repeat} равно \code{:none}, то после проигрывания последней песни из списка
\code{songs-table}, \code{current-song} переключается на значение по умолчанию. Когда
\code{repeat} равно \code{:song}, то все время проигрывается одна и та же песня из
\code{current-song}.  И если установлено значение \code{:all}, то после проигрывания
последней песни, сервер начинает играть с начала списка.

Слот \code{user-agent} хранит значение заголовка \code{User-Agent}, который отправлен
MP3-клиентом при запросе потока.  Вам нужно его держать исключительно для использования в
Web-интерфейсе~--- заголовок \code{User-Agent} идентифицирует программу, которая выполнила
запрос, так что вы можете отображать это значение на странице, на который перечислены все
списки песен, так что вам будет легче видеть какой из списков песен используется с каким
соединением, если к серверу подключено несколько клиентов.

И в заключение, слот \code{lock} хранит блокировку процесса (FIXME lock) созданную с
помощью функции \code{make-process-lock}, которая является частью пакета
\code{MULTIPROCESSING} из состава Allegro.  Вы будете использовать эту блокировку в
некоторых функциях, которые изменяют список песен, так что вы будете уверены в том, что
только один поток выполнения выполняет изменения списка.  Вы можете определить следующий
макрос, созданный на основе макроса \code{with-process-lock} из пакета
\code{MULTIPROCESSING}, чтобы облегчить написание кода, который должен быть выполнен при
захвате блокировки данного списка песен:

\begin{lstlisting}
(defmacro with-playlist-locked ((playlist) &body body)
  `(with-process-lock ((lock ,playlist))
     ,@body))
\end{lstlisting}

Макрос \code{with-process-lock} получает эксклюзивный доступ к блокировке процесса, и
затем выполняет переданные выражения, освобождая блокировку после их выполнения.  По
умолчанию, \code{with-process-lock} разрешает выполнять рекурсивные блокировки, что
значит, что один и тот же поток выполнения может захватывать одну и ту же блокировку
несколько раз.

\section{Списки песен как источники песен}

Для того, чтобы использовать списки песен в качестве источника песен для сервера
Shoutcast, вам нужно реализовать метод для обобщённой функции \code{find-song-source} из
главы~\ref{ch:28}.  Поскольку у вас будет множество списков песен, то вам необходим способ
нахождения нужного списка для конкретного клиента, подключённого к серверу.  Первая часть
работы достаточно легка~--- вы можете определить переменную, которая будет хранить
хэш-таблицу (с операцией сравнения \code{EQUAL}), которую вы сможете использовать для
отображения из некоторого идентификатора в список песен.

\begin{lstlisting}
(defvar *playlists* (make-hash-table :test #'equal))
\end{lstlisting}

Вы также можете определить блокировку процесса для защиты доступа к этой хэш-таблице,
например, вот так:

\begin{lstlisting}
(defparameter *playlists-lock* (make-process-lock :name "playlists-lock"))
\end{lstlisting}

Затем определим функцию, которая производит поиск списка песен по заданному
идентификатору, создавая новый список песен, если это необходимо, и используя
\code{with-process-lock} для обеспечения доступа к хэш-таблице только из одного потока
выполнения.\footnote{Описание проблем многопоточного программирования не является темой
  этой книги. Основная идея заключается в том, что если у вас есть несколько потоков
  выполнения (как в нашем случае, когда некоторые потоки выполняют функцию
  \code{shoutcast}, а другие обрабатывают запросы браузера), то вам нужно быть уверенным,
  что только один поток выполнения работает с конкретным объектом в конкретный момент
  времени.  Это делается чтобы другие потоки выполнения не видели не полностью изменённое
  состояние объекта в то время как конкретный поток работает с данным объектом.  В этой
  функции, например, если два новых MP3-клиента подключаются одновременно, то они оба
  будут пытаться добавить записи в таблицу \code{*playlists*}, и могут возникнуть накладки
  в работе.  Функция \code{with-process-lock} обеспечивает, что каждый поток выполнения
  получает эксклюзивный доступ к хэш-таблице на достаточно долгое время для выполнения
  нужной задачи.}

\begin{lstlisting}
(defun lookup-playlist (id)
  (with-process-lock (*playlists-lock*)
    (or (gethash id *playlists*)
        (setf (gethash id *playlists*) (make-instance 'playlist :id id)))))
\end{lstlisting}

Затем вы можете реализовать \code{find-song-source} на основе этой функции, а также
функцию \code{playlist-id}, которая получает объект \code{request} от AllegroServe и
возвращает соответствующий идентификатор списка песен.  В функции \code{find-song-source}
вы также получаете строку \code{User-Agent} из объекта \code{request}, и сохраняете её в
объекте \code{playlist}.

\begin{lstlisting}
(defmethod find-song-source ((type (eql 'playlist)) request)
  (let ((playlist (lookup-playlist (playlist-id request))))
    (with-playlist-locked (playlist)
      (let ((user-agent (header-slot-value request :user-agent)))
        (when user-agent (setf (user-agent playlist) user-agent))))
    playlist))
\end{lstlisting}

Хитрость заключается в том, как вы реализуете функцию \code{playlist-id}, которая
извлекает идентификатор из объекта \code{request}.  У вас имеется несколько возможностей,
каждая из которых по разному влияет на интерфейс пользователя.  Вы можете извлечь нужную
информацию из объекта \code{request}, но поскольку вы решили идентифицировать клиента, то
вам нужен какой-то способ связывания пользователя веб-интерфейса с соответствующим списком
песен.

В данный момент вы можете выбрать тот подход, который "просто работает", поскольку мы
подразумеваем, что есть только один MP3-клиент на компьютере, подключающемся к серверу,
также как и пользователь, работающий с веб-интерфейсом с компьютера, на котором запущен
MP3-клиент: вы будете использовать IP-адрес компьютера пользователя в качестве
идентификатор.  Таким образом вы можете найти соответствующий список песен для запроса,
вне зависимости от того, пришёл запрос от MP3-клиента или от веб-браузера.  Однако, вы
обеспечите в веб-интерфейсе возможность выбора другого списка песен, так что единственным
ограничением будет то, что только один MP3-клиент может быть доступен на компьютере
пользователя.\footnote{Этот подход также подразумевает, что каждый компьютер пользователя
  имеет уникальный IP-адрес.  Этот подход будет работать до тех пор, пока пользователи
  находятся в одной сети, но он не будет работать, если клиенты подключаются из-за
  межсетевого экрана, который выполняет преобразование адресов.  Развёртывание этого
  приложения вне локальной сети потребует внесения некоторых изменений, но если вы
  захотите развернуть это приложение в глобальной сети, то лучше узнать больше о сетевых
  технологиях, чтобы выбрать соответствующую схему отображения пользователей на списки
  песен.}  Реализация \code{playlist-id} выглядит примерно так:

\begin{lstlisting}
(defun playlist-id (request)
  (ipaddr-to-dotted (remote-host (request-socket request))))
\end{lstlisting}

Функция \code{request-socket} является частью AllegroServe, а \code{remote-host} и
\code{ipaddr-to-dotted} являются частью библиотеки Allegro для работы с сокетами.

Чтобы позволить использовать списки песен в качестве источников песен для сервера
Shoutcast, вам необходимо определить методы \code{current-song}, \code{still-current-p} и
\code{maybe-move-to-next-song}, которые специализируют параметр \code{source} для списка
песен. Метод \code{current-song} уже имеет эту функциональность: путём определения
процедуры доступа \code{current-song} для слота \code{eponymous}, вы автоматически
получите метод \code{current-song} специализированный для списков песен, который будет
возвращать значение этого слота. Однако, для того, чтобы сделать доступ к спискам песен
безопасным, вам необходимо блокировать доступ к списку песен до доступа к слоту
\code{current-song}.  В этом случае, самым простым способом будет определение метода
\code{:around}, например, вот так:

\begin{lstlisting}
(defmethod current-song :around ((playlist playlist))
  (with-playlist-locked (playlist) (call-next-method)))
\end{lstlisting}

Реализация \code{still-current-p} также достаточно простая, предполагая, что мы можем быть
уверены, что \code{current-song} будет обновлён на новый объект \code{song} только тогда,
когда текущая песня действительно сменится.  Вам снова нужно захватить блокировку процесса
для того, чтобы быть уверенным в консистентности состояния списка песен.

\begin{lstlisting}
(defmethod still-current-p (song (playlist playlist))
  (with-playlist-locked (playlist)
    (eql song (current-song playlist))))
\end{lstlisting}

Приём заключается в том, чтобы быть уверенным, что поле \code{current-song} будет
обновлено в нужное время.  Однако, текущая песня может быть изменена несколькими
способами.  Наиболее очевидным является вызов \code{maybe-move-to-next-song} сервером
Shoutcast.  Но текущая песня также может быть изменена в том случае, когда песни
добавляются к списку проигрывания; когда сервер Shoutcast исчерпывает список доступных
песен или когда изменяется режим повторения в списке проигрывания.

Вместо того, чтобы стараться писать в разных частях программы код для определения
необходимости обновления \code{current-song}, вы можете создать функцию
\code{update-current-if-necessary}, которая будет обновлять \code{current-song} если
объект \code{song} в \code{current-song} больше не соответствует файлу, который должен
проигрываться по информации в \code{current-idx}. Затем, если вы вызовите эту функцию
после любого изменения списка песен, которое может привести к тому, что эти два слота не
будут синхронизированны, то вы будете уверены что \code{current-song} имеет корректное
значение.  Вот код для функции \code{update-current-if-necessary} и её вспомогательных
функций:

\begin{lstlisting}
(defun update-current-if-necessary (playlist)
  (unless (equal (file (current-song playlist))
                 (file-for-current-idx playlist))
    (reset-current-song playlist)))

(defun file-for-current-idx (playlist)
  (if (at-end-p playlist)
    nil
    (column-value (nth-row (current-idx playlist) (songs-table playlist)) :file)))

(defun at-end-p (playlist)
  (>= (current-idx playlist) (table-size (songs-table playlist))))
\end{lstlisting}

Вам не нужно добавлять блокирование в эти функции, поскольку они будут вызываться только
из функций, которые сами озаботятся блокировкой списка песен в начале работы.

Функция \code{reset-current-song} использует ещё один прием: поскольку вы хотите чтобы
список песен обеспечивал бесконечный поток MP3 к клиенту, то вам не захочится
устанавливать \code{current-song} равным \code{NIL}. Вместо этого, когда список песен
исчерпает себя~--- когда \code{songs-table} пуст, или когда последняя песня была
проигранна, а значение \code{repeat} равно \code{:none}, то вам нужно установить
\code{current-song} равным специальной песне, чей файл с MP3 будет содержать
тишину\footnote{К сожалению, из-за лицензионных проблем вокруг формата MP3, непонятно,
  могу ли я выложить такой MP3 без уплаты лицензионных отчислений Fraunhofer IIS.  Я
  получил такой файл как часть ПО которое шло вместе с моим Slimp3 от Slim Devices. Вы
  можете взять этот файл из их репозитория Subversion:
  \url{http://svn.slimdevices.com/*checkout*/trunk/server/HTML/EN/html/silentpacket.mp3?rev=2}.
  Или купите, Squeezebox, новую, беспроводную версию Slimp3, и вы получите
  \code{silentpacket.mp3} как часть ПО, которое идёт вместе с ним. Или найдите MP3 версию
  песни 4'33", John Cage'а.} и чьё название объяснит почему музыка не играет.  Вот код,
который определяет два параметра: \code{*empty-playlist-song*} и
\code{*end-of-playlist-song*}, каждый из которых указывает на песню, хранящуюся в файле
\code{*silence-mp3*}, и имеет соответствующее название:

\begin{lstlisting}
(defparameter *silence-mp3* ...)

(defun make-silent-song (title &optional (file *silence-mp3*))
  (make-instance
   'song 
   :file file
   :title title
   :id3-size (if (id3-p file) (size (read-id3 file)) 0)))

(defparameter *empty-playlist-song* (make-silent-song "Playlist empty."))

(defparameter *end-of-playlist-song* (make-silent-song "At end of playlist."))
\end{lstlisting}

Функция \code{reset-current-song} использует эти параметры когда \code{current-idx} не
указывает на строку в \code{songs-table}.  В противном случае, она устанавливает
\code{current-song} в значение, соответствующее текущей строке.

\begin{lstlisting}
(defun reset-current-song (playlist)
  (setf
   (current-song playlist) 
   (cond
     ((empty-p playlist) *empty-playlist-song*)
     ((at-end-p playlist) *end-of-playlist-song*)
     (t (row->song (nth-row (current-idx playlist) (songs-table playlist)))))))

(defun row->song (song-db-entry)
  (with-column-values (file song artist album id3-size) song-db-entry
    (make-instance
     'song
     :file file
     :title (format nil "~a by ~a from ~a" song artist album)
     :id3-size id3-size)))

(defun empty-p (playlist)
  (zerop (table-size (songs-table playlist))))
\end{lstlisting}

Наконец-то вы можете реализовать метод \code{maybe-move-to-next-song} который перемещает
\code{current-idx} к следующему значению, основываясь на режиме повторения в списке песен,
а затем вызывает \code{update-current-if-necessary}.  Вы не будете изменять
\code{current-idx} когда он уже в конце списка песен, поскольку вы хотите сохранить его
текущее значение, так что он будет указывать на следующую песню, которую вы добавите к
списку песен.  Эта функция должна заблокировать список песен до внесения изменений,
поскольку она будет вызвана сервером Shoutcast server code, который не делает никаких
блокировок.

\begin{lstlisting}
(defmethod maybe-move-to-next-song (song (playlist playlist))
  (with-playlist-locked (playlist)
    (when (still-current-p song playlist)
      (unless (at-end-p playlist)
        (ecase (repeat playlist)
          (:song) ; nothing changes
          (:none (incf (current-idx playlist)))
          (:all  (setf (current-idx playlist)
                       (mod (1+ (current-idx playlist))
                            (table-size (songs-table playlist)))))))
      (update-current-if-necessary playlist))))
\end{lstlisting}

\section{Изменение списка песен}

Остальная часть кода плейлиста это функции которые используются веб интерфейсом чтобы
выполнять действия с объектами \code{playlist}, включая добавление и удаление песен,
сортировку и перемешивание а также установку режима повтора. Как во вспомогательных
функциях предыдущей секции, вам не нужно беспокоиться о блокировке и в этих функциях
потому что, как вы увидите, блокировка будет включена в функциях веб интерфейса вызывающих
эти.

Добавление и удаление это в основном вопрос управления списком песен. Единственная
дополнительная работа которую вам нужно сделать это держать синхронизированными
\code{current-song} и \code{current-idx}. Например, когда плейлист пустой, его
\code{current-idx} будет 0, а \code{current-song} будет \code{*empty-playlist-song*}. Если
вы добавите песню в пустой плейлист, тогда нулевой индекс попадает в границы и вы должны
изменить \code{current-song} на только что добавленную песню. К тому же если вы проиграли все
песни в плейлисте и в \code{current-song} значение \code{*end-of-playlist-song*},
добавление песни должно вызвать сброс \code{current-song}. Все это на самом деле означает что
вам нужно вызывать\code{update-current-if-necessary} в соответствующих местах. 

Добавление песен в плейлист немного запутано из-за способа которым веб интерфейс узнает
выбранную песню. По причинам которые я оговорю в следующей секции, код веб интерфейса просто
не может дать вам простой набор критериев для выборки песен из базы данных. Вместо этого он дает
вам имя колонки и список значений, а вы должны добавить все песни из главной базы данных
где данная колонка имеет значение в списке значений. Таким образом, чтобы добавить
правильные песни, вам нужно сначала построить объект таблицы с нужными значениями, который
вы можете потом использовать во внутреннем запросе к базы данных песен. Итак,
\code{add-songs} выглядит так:

\begin{lstlisting}
(defun add-songs (playlist column-name values)
  (let ((table (make-instance
                'table 
                :schema (extract-schema (list column-name) (schema *mp3s*)))))
    (dolist (v values) (insert-row (list column-name v) table))
    (do-rows (row (select :from *mp3s* :where (in column-name table)))
      (insert-row row (songs-table playlist))))
  (update-current-if-necessary playlist))
\end{lstlisting}

Удаление песен немного проще; вам только нужна возможность удалять песни из
\code{songs-table} которые удовлетворяют конкретный критерий~--- или конкретную песню или
все песни в конкретном жанре, по конкретному исполнителю или из конкретного альбома. Итак,
вы можете предоставить функцию \code{delete-songs} которая берет пары ключ/значение,
которые используются для построения сравнительное условие \code{:where} для передачи в функцию
базы данных \code{delete-rows}.

Другая сложность которая возникает при удалении песен это то что может быть необходимость
в изменении \code{current-idx}. Допуская что текущая песня не из тех которые только что
удалили, вам бы хотелось оставить текущую песню. Но если песни перед ней в
\code{songs-table} удалены, она будет на другой позиции в таблице после удаления. Итак,
после вызова \code{delete-rows}, вам нужно будет посмотреть на строку содержащую текущую
песню и сбросить \code{current-idx}. Если текущая песня сама была удалена, тогда, за
неимением лучшего варианта, вы можете сбросить \code{current-idx} к нулю. После обновления
\code{current-idx}, вызов \code{update-current-if-necessary} позаботится об обновлении
\code{current-song}. И если \code{current-idx} изменился но все же указывает на ту же
песню, \code{current-song} не будет затронута.

\begin{lstlisting}
(defun delete-songs (playlist &rest names-and-values)
  (delete-rows
   :from (songs-table playlist)
   :where (apply #'matching (songs-table playlist) names-and-values))
  (setf (current-idx playlist) (or (position-of-current playlist) 0))
  (update-current-if-necessary playlist))

(defun position-of-current (playlist)
  (let* ((table (songs-table playlist))
         (matcher (matching table :file (file (current-song playlist))))
         (pos 0))
    (do-rows (row table)
      (when (funcall matcher row)
        (return-from position-of-current pos))
      (incf pos))))
\end{lstlisting}

Вы также можете предоставить функцию для полного очищения плейлиста которая использует
\code{delete-all-rows} и не должна беспокоиться о поиске текущей песни, поскольку очевидно
что она будет удалена. Вызов \code{update-current-if-necessary} позаботится об
установлении \code{current-song} в NIL.

\begin{lstlisting}
(defun clear-playlist (playlist)
  (delete-all-rows (songs-table playlist))
  (setf (current-idx playlist) 0)
  (update-current-if-necessary playlist))
\end{lstlisting}

Сортировка и перемешивание плейлиста связаны тем что плейлист всегда либо отсортирован
либо перемешан. Слот \code{shuffle} говорит был ли плейлист перемешан и если так то каким
образом. Если он установлен в \code{:none}, тогда плейлист отсортирован в соответствии со
значением слота сортировки. Если \code{shuffle} равен \code{:song}, плейлист будет
случайным образом перемешан. И когда он установлен в \code{:album}, список альбомов
случайным образом перемешан, но песни каждого альбома отображаются по порядку. Таким
образом функция \code{sort-playlist}, которая будет вызываться кодом веб интерфейса когда
пользователь будет выбирать новый порядок сортировки, должна установить порядок сортировки
в нужный и установить \code{shuffle} в \code{:none} перед вызовом \code{order-playlist},
который на самом деле не сортирует. Также как и в \code{delete-songs}, вам нужно
использовать \code{position-of-current} для сброса \code{current-idx} в новую позицию
текущей песни. Тем не менее, в этот раз вы не нуждаетесь в вызове
\code{update-current-if-necessary} поскольку вы знаете что текущая песня все еще в
таблице.

\begin{lstlisting}
(defun sort-playlist (playlist ordering)
  (setf (ordering playlist) ordering)
  (setf (shuffle playlist) :none)
  (order-playlist playlist)
  (setf (current-idx playlist) (position-of-current playlist)))
\end{lstlisting}

В \code{order-playlist} вы можете использовать функцию базы данных \code{sort-rows} чтобы
действительно совершить сортировку, передавая список колонок для сортировки в зависимости
от значения \code{ordering}.

\begin{lstlisting}
(defun order-playlist (playlist)
  (apply #'sort-rows (songs-table playlist)
    (case (ordering playlist)
      (:genre  '(:genre :album :track))
      (:artist '(:artist :album :track))
      (:album  '(:album :track))
      (:song   '(:song)))))
\end{lstlisting}

Функция \code{shuffle-playlist}, которая вызывается кодом веб интерфейса когда
пользователь выбирает новый режим перемешивания, работает аналогичным образом, кром того
что не нуждается в изменении значения \code{ordering}. Таким образом, когда
\code{shuffle-playlist} вызывается с \code{shuffle} равным \code{:none}, плейлист
возвращается к сортировки в соответствии с предыдущим \code{ordering}. Перемешивание песен
простое~--- нужно только вызвать \code{shuffle-table} для \code{songs-table}.
Перемешивание альбомов немножко запутаннее но все же не ядерная физика.

\begin{lstlisting}
(defun shuffle-playlist (playlist shuffle)
  (setf (shuffle playlist) shuffle)
  (case shuffle
    (:none (order-playlist playlist))
    (:song (shuffle-by-song playlist))
    (:album (shuffle-by-album playlist)))
  (setf (current-idx playlist) (position-of-current playlist)))

(defun shuffle-by-song (playlist)
  (shuffle-table (songs-table playlist)))

(defun shuffle-by-album (playlist)
  (let ((new-table (make-playlist-table)))
    (do-rows (album-row (shuffled-album-names playlist))
      (do-rows (song (songs-for-album playlist (column-value album-row :album)))
        (insert-row song new-table)))
    (setf (songs-table playlist) new-table)))

(defun shuffled-album-names (playlist)
  (shuffle-table 
   (select
    :columns :album
    :from (songs-table playlist)
    :distinct t)))

(defun songs-for-album (playlist album)
  (select
   :from (songs-table playlist) 
   :where (matching (songs-table playlist) :album album)
   :order-by :track))
\end{lstlisting}

Последняя манипуляция которую вам необходимо поддерживать это установка режима повтора для
плейлиста. Большую часть времени вы не нуждаетесь в дополнительных действиях когда
устанавливаете повтор~---его значение входит в игру только в
\code{maybe-move-to-next-song}.  Тем не менее, вам нужно обновить \code{current-song} как
результат изменения повтора в одной ситуации, а именно, если \code{current-idx} в конце не
пустого плейлиста и повтор изменяется с \code{:song} или \code{:all}. В этом случае, вы
хотите продолжить проигрывание либо повторяя последнюю песню или стартовать с самого
начала плейлиста. Итак, вы должны определить метод \code{:after} для обобщенной функции
\code{(setf repeat)}.

\begin{lstlisting}
(defmethod (setf repeat) :after (value (playlist playlist))
  (if (and (at-end-p playlist) (not (empty-p playlist)))
    (ecase value
      (:song (setf (current-idx playlist) (1- (table-size (songs-table playlist)))))
      (:none)
      (:all  (setf (current-idx playlist) 0)))
    (update-current-if-necessary playlist)))
\end{lstlisting}

Теперь вы имеете все основные кусочки которые нужны. Все это остается в коде который
предоставит пользовательский веб интерфейс для просмотра базы данных MP3 и обработку
плейлистов. Интерфейс будет состоять из трех главных функций определенных с помощью
\code{define-url-function}: одна для просмотра базы данных песен, одна для просмотра и
обработки одного плейлиста и одна для списка всех доступных плейлистов.

Но прежде чем вы начнете писать эти три функции, вам нужно начать с некоторых
вспомогательных функций и HTML макросов для использования внутри их.

\section{Типы параметров запроса}

Поскольку вы будете использовать \code{define-url-function}, вам нужно определить
несколько методов для обобщенной функции \code{string->type} с главы~\ref{ch:28} которые
\code{define-url-function} использует для преобразования строки параметров запроса в Lisp
объекты. В этом приложении вам нужны будут методы для преобразования строк в целые числа,
ключевые символы и списки значений.

Первые два достаточно просты.

\begin{lstlisting}
(defmethod string->type ((type (eql 'integer)) value)
  (parse-integer (or value "") :junk-allowed t))

(defmethod string->type ((type (eql 'keyword)) value)
  (and (plusp (length value)) (intern (string-upcase value) :keyword)))
\end{lstlisting}

Последний \code{string->type} метод немного более сложный. Из-за причин к которым доберусь
через мгновение, вам нужно генерировать страницы которые отображают форму со скрытым
полем, значение которого список строк. Поскольку вы ответственны за генерацию значения в
скрытом поле и за ее разбор когда она будет возвращена, вы можете использовать любую
удобную кодировку. Вы можете использовать функции \code{WRITE-TO-STRING} и
\code{READ-FROM-STRING}, которые используют считыватель и механизм вывода Lisp для записи
и считывания данных со строк, кроме того что печатное представление строк может вмещать
знаки кавычек и другие символы которые могут вызвать проблемы будучи внутри значения
атрибута элемента \code{INPUT}. Итак, вам нужно экранировать как-то такие значения. Прежде
тем как придумывать свой способ экранирования, вы можете просто использовать base64,
кодировку обычно используемую ля защиты двоичных данных посылаемых по e-mail. AllegroServe
имеет две функции, \code{base64-encode} и \code{base64-decode}, которые делают кодирование
и декодирование для вас, таким образом, все, что вам нужно сделать это написать пару
функций: одна кодирует Lisp объект, превращая его в читабельную строку с
\code{WRITE-TO-STRING} а потом кодирует ее с base64, и, обратно, другую для декодирования
такой строки из base64 и передачи результата декодирования в \code{READ-FROM-STRING}. Вам
захочется обернуть вызовы к \code{WRITE-TO-STRING} и \code{READ-FROM-STRING} в
\code{WITH-STANDARD-IO-SYNTAX} для того чтобы быть уверенными что все переменные которые
влияют на механизмы чтения и вывода установлены в свои стандартные значения. Тем не менее,
поскольку вы собираетесь читать данные которые приходят из сети, вы, разумеется, хотите
выключить одну функцию считывателя~--- возможность выполнения произвольного кода Lisp во
время чтения!\footnote{Считыватель поддерживает неполный синтаксис, \lstinline!#.!,
который заставляет выполнение s-выражения идущего за ним во время считывания. Это иногда
полезно в исходном коде но явно открывает большую дырку в безопасности когда вы считываете
ненадежные данные. Тем не менее, вы можете выключить этот синтаксис установив значение
\code{*READ-EVAL} в \code{NIL}, что заставит считыватель генерировать ошибку когда он
встретит \lstinline!#.!.} Вы можете определить собственный макрос
\code{with-safe-io-syntax}, который обернет формы тела макроса в
\code{WITH-STANDARD-IO-SYNTAX} внутри кода \code{LET} который привяжет \code{*READ-EVAL} к
значению \code{NIL}.

\begin{lstlisting}
(defmacro with-safe-io-syntax (&body body)
  `(with-standard-io-syntax
     (let ((*read-eval* nil))
       ,@body)))
\end{lstlisting}

В таком случае функции кодирования и декодирования тривиальны.

\begin{lstlisting}
(defun obj->base64 (obj)
  (base64-encode (with-safe-io-syntax (write-to-string obj))))

(defun base64->obj (string)
  (ignore-errors
    (with-safe-io-syntax (read-from-string (base64-decode string)))))
\end{lstlisting}

Наконец, вы можете использовать эти функции для определения метода для
\lstinline!string->type! который определит преобразование для типа параметра запроса
\code{base64-list}

\begin{lstlisting}
(defmethod string->type ((type (eql 'base-64-list)) value)
  (let ((obj (base64->obj value)))
    (if (listp obj) obj nil)))
\end{lstlisting}

\section{Boilerplate HTML}

Next you need to define some HTML macros and helper functions to make it easy to give the
different pages in the application a consistent look and feel. You can start with an HTML
macro that defines the basic structure of a page in the application.

\begin{lstlisting}
(define-html-macro :mp3-browser-page ((&key title (header title)) &body body)
  `(:html
     (:head
      (:title ,title)
      (:link :rel "stylesheet" :type "text/css" :href "mp3-browser.css"))
     (:body
      (standard-header)
      (when ,header (html (:h1 :class "title" ,header)))
      ,@body
      (standard-footer))))
\end{lstlisting}

You should define standard-header and standard-footer as separate functions for two
reasons. First, during development you can redefine those functions and see the effect
immediately without having to recompile functions that use the :mp3-browser-page
macro. Second, it turns out that one of the pages you'll write later won't be defined with
:mp3-browser-page but will still need the standard header and footers. They look like
this:

\begin{lstlisting}
(defparameter *r* 25)

(defun standard-header ()
  (html
   ((:p :class "toolbar")
    "[" (:a :href (link "/browse" :what "genre") "All genres") "] "
    "[" (:a :href (link "/browse" :what "genre" :random *r*) "Random genres") "] "
    "[" (:a :href (link "/browse" :what "artist") "All artists") "] "
    "[" (:a :href (link "/browse" :what "artist" :random *r*) "Random artists") "] "
    "[" (:a :href (link "/browse" :what "album") "All albums") "] "
    "[" (:a :href (link "/browse" :what "album" :random *r*) "Random albums") "] "
    "[" (:a :href (link "/browse" :what "song" :random *r*) "Random songs") "] "
    "[" (:a :href (link "/playlist") "Playlist") "] "
    "[" (:a :href (link "/all-playlists") "All playlists") "]")))

(defun standard-footer ()
  (html (:hr) ((:p :class "footer") "MP3 Browser v" *major-version* "." *minor-version*)))
\end{lstlisting}

A couple of smaller HTML macros and helper functions automate other common patterns. The
:table-row HTML macro makes it easier to generate the HTML for a single row of a table. It
uses a feature of FOO that I'll discuss in Chapter~\ref{ch:31}, an \lstinline!&attributes!
parameter, which causes uses of the macro to be parsed just like normal s-expression HTML
forms, with any attributes gathered into a list that will be bound to the
\lstinline!&attributes!  parameter. It looks like this:

\begin{lstlisting}
(define-html-macro :table-row (&attributes attrs &rest values)
  `(:tr ,@attrs ,@(loop for v in values collect `(:td ,v))))
\end{lstlisting}

And the link function generates a URL back into the application to be used as the HREF
attribute with an A element, building a query string out of a set of keyword/value pairs
and making sure all special characters are properly escaped. For instance, instead of
writing this:

\begin{lstlisting}
(:a :href "browse?what=artist&genre=Rhythm+%26+Blues" "Artists")
\end{lstlisting}

you can write the following:

\begin{lstlisting}
(:a :href (link "browse" :what "artist" :genre "Rhythm & Blues") "Artists")
\end{lstlisting}

It looks like this:

\begin{lstlisting}
(defun link (target &rest attributes)
  (html 
    (:attribute
     (:format "~a~@[?~{~(~a~)=~a~^&~}~]" target (mapcar #'urlencode attributes)))))
\end{lstlisting}

To URL encode the keys and values, you use the helper function urlencode, which is a
wrapper around the function encode-form-urlencoded, which is a nonpublic function from
AllegroServe. This is~--- on one hand~--- bad form; since the name encode-form-urlencoded isn't
exported from NET.ASERVE, it's possible that encode-form-urlencoded may go away or get
renamed out from under you. On the other hand, using this unexported symbol for the time
being lets you get work done for the moment; by wrapping encode-form-urlencoded in your
own function, you isolate the crufty code to one function, which you could rewrite if you
had to.

\begin{lstlisting}
(defun urlencode (string)
  (net.aserve::encode-form-urlencoded string))
\end{lstlisting}

Finally, you need the CSS style sheet mp3-browser.css used by :mp3-browser-page. Since
there's nothing dynamic about it, it's probably easiest to just publish a static file with
publish-file.

\begin{lstlisting}
(publish-file :path "/mp3-browser.css"  :file filename :content-type "text/css")
\end{lstlisting}

A sample style sheet is included with the source code for this chapter on the book's Web
site. You'll define a function, at the end of this chapter, that starts the MP3 browser
application. It'll take care of, among other things, publishing this file.

\section{The Browse Page}

The first URL function will generate a page for browsing the MP3 database. Its query
parameters will tell it what kind of thing the user is browsing and provide the criteria
of what elements of the database they're interested in. It'll give them a way to select
database entries that match a specific genre, artist, or album. In the interest of
serendipity, you can also provide a way to select a random subset of matching items. When
the user is browsing at the level of individual songs, the title of the song will be a
link that causes that song to be added to the playlist. Otherwise, each item will be
presented with links that let the user browse the listed item by some other category. For
example, if the user is browsing genres, the entry "Blues" will contain links to browse
all albums, artists, and songs in the genre Blues. Additionally, the browse page will
feature an "Add all" button that adds every song matching the page's criteria to the
user's playlist. The function looks like this:

\begin{lstlisting}
(define-url-function browse
    (request (what keyword :genre) genre artist album (random integer))

  (let* ((values (values-for-page what genre artist album random))
         (title (browse-page-title what random genre artist album))
         (single-column (if (eql what :song) :file what))
         (values-string (values->base-64 single-column values)))
    (html
     (:mp3-browser-page
      (:title title)
      ((:form :method "POST" :action "playlist")
       (:input :name "values" :type "hidden" :value values-string)
       (:input :name "what" :type "hidden" :value single-column)
       (:input :name "action" :type "hidden" :value :add-songs)
       (:input :name "submit" :type "submit" :value "Add all"))
      (:ul (do-rows (row values) (list-item-for-page what row)))))))
\end{lstlisting}

This function starts by using the function values-for-page to get a table containing the
values it needs to present. When the user is browsing by song~--- when the what parameter is
:song~--- you want to select complete rows from the database. But when they're browsing by
genre, artist, or album, you want to select only the distinct values for the given
category. The database function select does most of the heavy lifting, with
values-for-page mostly responsible for passing the right arguments depending on the value
of what. This is also where you select a random subset of the matching rows if necessary.

\begin{lstlisting}
(defun values-for-page (what genre artist album random)
  (let ((values
         (select 
          :from *mp3s*
          :columns (if (eql what :song) t what)
          :where (matching *mp3s* :genre genre :artist artist :album album)
          :distinct (not (eql what :song))
          :order-by (if (eql what :song) '(:album :track) what))))
    (if random (random-selection values random) values)))
\end{lstlisting}

To generate the title for the browse page, you pass the browsing criteria to the following
function, browse-page-title:

\begin{lstlisting}
(defun browse-page-title (what random genre artist album)
  (with-output-to-string (s)
    (when random (format s "~:(~r~) Random " random))
    (format s "~:(~a~p~)" what random)
    (when (or genre artist album)
      (when (not (eql what :song)) (princ " with songs" s))
      (when genre  (format s " in genre ~a" genre))
      (when artist (format s " by artist ~a " artist))
      (when album  (format s " on album ~a" album)))))
\end{lstlisting}

Once you have the values you want to present, you need to do two things with them. The
main task, of course, is to present them, which happens in the do-rows loop, leaving the
rendering of each row to the function list-item-for-page. That function renders :song rows
one way and all other kinds another way.

\begin{lstlisting}
(defun list-item-for-page (what row)
  (if (eql what :song)
    (with-column-values (song file album artist genre) row
      (html
        (:li
         (:a :href (link "playlist" :file file :action "add-songs") (:b song)) " from "
         (:a :href (link "browse"  :what :song :album  album) album) " by "
         (:a :href (link "browse" :what :song :artist artist) artist) " in genre "
         (:a :href (link "browse"  :what :song :genre  genre) genre))))
    (let ((value (column-value row what)))
      (html
       (:li value " - "
            (browse-link :genre  what value)
            (browse-link :artist what value)
            (browse-link :album  what value)
            (browse-link :song   what value))))))

(defun browse-link (new-what what value)
  (unless (eql new-what what)
    (html
     "[" 
     (:a :href (link "browse" :what new-what what value) (:format "~(~as~)" new-what))
     "] ")))
\end{lstlisting}

The other thing on the browse page is a form with several hidden INPUT fields and an "Add
all" submit button. You need to use an HTML form instead of a regular link to keep the
application stateless~--- to make sure all the information needed to respond to a request
comes in the request itself. Because the browse page results can be partially random, you
need to submit a fair bit of data for the server to be able to reconstitute the list of
songs to add to the playlist. If you didn't allow the browse page to return randomly
generated results, you wouldn't need much data~--- you could just submit a request to add
songs with whatever search criteria the browse page used. But if you added songs that way,
with criteria that included a random argument, then you'd end up adding a different set of
random songs than the user was looking at on the page when they hit the "Add all" button.

The solution you'll use is to send back a form that has enough information stashed away in
a hidden INPUT element to allow the server to reconstitute the list of songs matching the
browse page criteria. That information is the list of values returned by values-for-page
and the value of the what parameter. This is where you use the base64-list parameter type;
the function values->base64 extracts the values of a specified column from the table
returned by values-for-page into a list and then makes a base 64-encoded string out of
that list to embed in the form.

\begin{lstlisting}
(defun values->base-64 (column values-table)
  (flet ((value (r) (column-value r column)))
    (obj->base64 (map-rows #'value values-table))))
\end{lstlisting}

When that parameter comes back as the value of the values query parameter to a URL
function that declares values to be of type base-64-list, it'll be automatically converted
back to a list. As you'll see in a moment, that list can then be used to construct a query
that'll return the correct list of songs.\footnote{This solution has its drawbacks~---if a
  browse page returns a lot of results, a fair bit of data is going back and forth under
  the covers. Also, the database queries aren't necessarily the most efficient. But it
  does keep the application stateless. An alternative approach is to squirrel away, on the
  server side, information about the results returned by browse and then, when a request
  to add songs come in, find the appropriate bit of information in order to re-create the
  correct set of songs. For instance, you could just save the values list instead of
  sending it back in the form. Or you could copy the RANDOM-STATE object before you
  generate the browse results so you can later re-create the same "random" results. But
  this approach causes its own problems. For instance, you'd then need to worry about when
  you can get rid of the squirreled-away information; you never know when the user might
  hit the Back button on their browser to return to an old browse page and then hit the
  "Add all" button. Welcome to the wonderful world of Web programming.} When you're
browsing by :song, you use the values from the :file column since they uniquely identify
the actual songs while the song names may not.

\section{The Playlist}

This brings me to the next URL function, playlist. This is the most complex page of the
three~---it's responsible for displaying the current contents of the user's playlist as
well as for providing the interface to manipulate the playlist. But with most of the
tedious bookkeeping handled by define-url-function, it's not too hard to see how playlist
works. Here's the beginning of the definition, with just the parameter list:

\begin{lstlisting}
(define-url-function playlist 
    (request
     (playlist-id string (playlist-id request) :package)
     (action keyword)      ; Playlist manipulation action
     (what keyword :file)  ; for :add-songs action
     (values base-64-list) ;             "
     file                  ; for :add-songs and :delete-songs actions
     genre                 ; for :delete-songs action
     artist                ;             "
     album                 ;             "
     (order-by keyword)    ; for :sort action
     (shuffle keyword)     ; for :shuffle action
     (repeat keyword))     ; for :set-repeat action
\end{lstlisting}

In addition to the obligatory request parameter, playlist takes a number of query
parameters. The most important in some ways is playlist-id, which identifies which
playlist object the page should display and manipulate. For this parameter, you can take
advantage of define-url-function's "sticky parameter" feature. Normally, the playlist-id
won't be supplied explicitly, defaulting to the value returned by the playlist-id
function, namely, the IP address of the client machine on which the browser is
running. However, users can also manipulate their playlists from different machines than
the ones running their MP3 clients by allowing this value to be explicitly specified. And
if it's specified once, define-url-function will arrange for it to "stick" by setting a
cookie in the browser. Later you'll define a URL function that generates a list of all
existing playlists, which users can use to pick a playlist other than the one for the
machines they're browsing from.

The action parameter specifies some action to take on the user's playlist object. The
value of this parameter, which will be converted to a keyword symbol for you, can be
:add-songs, :delete-songs, :clear, :sort, :shuffle, or :set-repeat. The :add-songs action
is used by the "Add all" button in the browse page and also by the links used to add
individual songs. The other actions are used by the links on the playlist page itself.

The file, what, and values parameters are used with the :add-songs action. By declaring
values to be of type base-64-list, the define-url-function infrastructure will take care
of decoding the value submitted by the "Add all" form. The other parameters are used with
other actions as noted in the comments.

Now let's look at the body of playlist. The first thing you need to do is use the
playlist-id to look up the queue object and then acquire the playlist's lock with the
following two lines:

\begin{lstlisting}
(let ((playlist (lookup-playlist playlist-id)))
  (with-playlist-locked (playlist)
\end{lstlisting}

Since lookup-playlist will create a new playlist if necessary, this will always return a
playlist object. Then you take care of any necessary queue manipulation, dispatching on
the value of the action parameter in order to call one of the playlist functions.

\begin{lstlisting}
(case action
  (:add-songs      (add-songs playlist what (or values (list file))))
  (:delete-songs   (delete-songs 
                    playlist 
                    :file file :genre genre
                    :artist artist :album album))
  (:clear          (clear-playlist playlist))
  (:sort           (sort-playlist playlist order-by))
  (:shuffle        (shuffle-playlist playlist shuffle))
  (:set-repeat     (setf (repeat playlist) repeat)))
\end{lstlisting}

All that's left of the playlist function is the actual HTML generation. Again, you can use
the :mp3-browser-page HTML macro to make sure the basic form of the page matches the other
pages in the application, though this time you pass NIL to the :header argument in order
to leave out the H1 header. Here's the rest of the function:

\begin{lstlisting}
(html
 (:mp3-browser-page
  (:title (:format "Playlist - ~a" (id playlist)) :header nil)
  (playlist-toolbar playlist)
  (if (empty-p playlist)
    (html (:p (:i "Empty.")))
    (html 
      ((:table :class "playlist")
       (:table-row "#" "Song" "Album" "Artist" "Genre")
       (let ((idx 0)
             (current-idx (current-idx playlist)))
         (do-rows (row (songs-table playlist))
           (with-column-values (track file song album artist genre) row
             (let ((row-style (if (= idx current-idx) "now-playing" "normal")))
               (html
                 ((:table-row :class row-style)
                  track
                  (:progn song   (delete-songs-link :file file))
                  (:progn album  (delete-songs-link :album album))
                  (:progn artist (delete-songs-link :artist artist))
                  (:progn genre  (delete-songs-link :genre genre)))))
             (incf idx))))))))))))
\end{lstlisting}

The function playlist-toolbar generates a toolbar containing links to playlist to perform
the various :action manipulations. And delete-songs-link generates a link to playlist with
the :action parameter set to :delete-songs and the appropriate arguments to delete an
individual file, or all files on an album, by a particular artist or in a specific genre.

\begin{lstlisting}
(defun playlist-toolbar (playlist)
  (let ((current-repeat (repeat playlist))
        (current-sort (ordering playlist))
        (current-shuffle (shuffle playlist)))
    (html
     (:p :class "playlist-toolbar"
         (:i "Sort by:")
         " [ "
         (sort-playlist-button "genre" current-sort) " | " 
         (sort-playlist-button "artist" current-sort) " | " 
         (sort-playlist-button "album" current-sort) " | " 
         (sort-playlist-button "song" current-sort) " ] "
         (:i "Shuffle by:")
         " [ "
         (playlist-shuffle-button "none" current-shuffle) " | "
         (playlist-shuffle-button "song" current-shuffle) " | "
         (playlist-shuffle-button "album" current-shuffle) " ] "
         (:i "Repeat:")
         " [ "
         (playlist-repeat-button "none" current-repeat) " | "
         (playlist-repeat-button "song" current-repeat) " | "
         (playlist-repeat-button "all" current-repeat) " ] "
         "[ " (:a :href (link "playlist" :action "clear") "Clear") " ] "))))

(defun playlist-button (action argument new-value current-value)
  (let ((label (string-capitalize new-value)))
    (if (string-equal new-value current-value)
      (html (:b label))
      (html (:a :href (link "playlist" :action action argument new-value) label)))))

(defun sort-playlist-button (order-by current-sort)
  (playlist-button :sort :order-by order-by current-sort))

(defun playlist-shuffle-button (shuffle current-shuffle)
  (playlist-button :shuffle :shuffle shuffle current-shuffle))

(defun playlist-repeat-button (repeat current-repeat)
  (playlist-button :set-repeat :repeat repeat current-repeat))

(defun delete-songs-link (what value)
  (html " [" (:a :href (link "playlist" :action :delete-songs what value) "x") "]"))
\end{lstlisting}

\section{Finding a Playlist}

The last of the three URL functions is the simplest. It presents a table listing all the
playlists that have been created. Ordinarily users won't need to use this page, but during
development it gives you a useful view into the state of the system. It also provides the
mechanism to choose a different playlist~--- each playlist ID is a link to the playlist
page with an explicit playlist-id query parameter, which will then be made sticky by the
playlist URL function. Note that you need to acquire the *playlists-lock* to make sure the
*playlists* hash table doesn't change out from under you while you're iterating over it.

\begin{lstlisting}
(define-url-function all-playlists (request)
  (:mp3-browser-page
   (:title "All Playlists")
   ((:table :class "all-playlists")
    (:table-row "Playlist" "# Songs" "Most recent user agent")
    (with-process-lock (*playlists-lock*)
      (loop for playlist being the hash-values of *playlists* do
           (html
             (:table-row
              (:a :href (link "playlist" :playlist-id (id playlist)) (:print (id playlist)))
              (:print (table-size (songs-table playlist)))
              (:print (user-agent playlist)))))))))
\end{lstlisting}

\section{Running the App}

And that's it. To use this app, you just need to load the MP3 database with the
load-database function from Chapter 27, publish the CSS style sheet, set
*song-source-type* to playlist so find-song-source uses playlists instead of the singleton
song source defined in the previous chapter, and start AllegroServe. The following
function takes care of all these steps for you, after you fill in appropriate values for
the two parameters *mp3-dir*, which is the root directory of your MP3 collection, and
*mp3-css*, the filename of the CSS style sheet:

\begin{lstlisting}
(defparameter *mp3-dir* ...)

(defparameter *mp3-css* ...)

(defun start-mp3-browser ()
  (load-database *mp3-dir* *mp3s*)
  (publish-file :path "/mp3-browser.css"  :file *mp3-css* :content-type "text/css")
  (setf *song-source-type* 'playlist)
  (net.aserve::debug-on :notrap)
  (net.aserve:start :port 2001))
\end{lstlisting}

When you invoke this function, it will print dots while it loads the ID3 information from
your ID3 files. Then you can point your MP3 client at this URL:

\begin{verbatim}
  http://localhost:2001/stream.mp3
\end{verbatim}

and point your browser at some good starting place, such as this:

\begin{verbatim}
  http://localhost:2001/browse
\end{verbatim}

which will let you start browsing by the default category, Genre. After you've added some
songs to the playlist, you can press Play on the MP3 client, and it should start playing
the first song.

Obviously, you could improve the user interface in any of a number of ways~--- for
instance, if you have a lot of MP3s in your library, it might be useful to be able to
browse artists or albums by the first letter of their names. Or maybe you could add a
"Play whole album" button to the playlist page that causes the playlist to immediately put
all the songs from the same album as the currently playing song at the top of the
playlist. Or you could change the playlist class, so instead of playing silence when there
are no songs queued up, it picks a random song from the database. But all those ideas fall
in the realm of application design, which isn't really the topic of this book. Instead,
the next two chapters will drop back to the level of software infrastructure to cover how
the FOO HTML generation library works.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
