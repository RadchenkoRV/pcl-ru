\chapter{Коллекции}
\label{ch:11}

Как и в большинстве языков программирования, в Common Lisp есть стандартные типы данных,
собирающие несколько значений в один объект.  Каждый язык решает проблему коллекций
немного по-разному, но базовые типы коллекций обычно сводятся к типу массивов с целочисленными
индексами и типу таблиц, способных отображать более или менее
произвольные ключи в значения.  Первые называются \textit{массивами}, \textit{списками} или \textit{кортежами}, а
вторые~--- \textit{хэш-таблицами}, \textit{ассоциативными массивами}, \textit{картами} и \textit{словарями}.

Конечно, Lisp знаменит своими списками, поэтому, согласно принципу <<Онтогенез повторяет
филогенез>>, большинство учебников по Lisp начинает объяснение коллекций со
списков. Однако такой подход часто приводит читателей к ошибочному выводу, что
список~--- \textit{единственный} тип коллекций в Lisp.  Что ещё хуже,
списки Lisp~--- структуры, настолько гибкие, что их можно использовать для многих целей, для
которых в других языках используются массивы и хэш-таблицы.  Но было бы ошибкой слишком
сильно сосредоточиваться на списках; хотя они и являются ключевой структурой данных для
представления Lisp-кода в виде Lisp-данных, во многих случаях более уместны другие структуры данных.

Чтобы списки не затмили всё остальное, в этой главе я сосредоточусь на других типах
коллекций Common Lisp: векторах и хэш-таблицах\footnote{Когда вы познакомитесь со всеми
  типами данных в Common Lisp, то увидите, что может быть полезно сначала моделировать
  структуру данных с помощью списков, а затем, после того как станет ясно, как именно данные
  будут использоваться, заменять списки на что-то более эффективное.}.
Однако векторы и списки имеют достаточно много общих признаков, так что Common Lisp
рассматривает их как подтипы более общей абстракции~--- последовательности.  Таким образом,
многие функции, описанные в этой главе, можно использовать как для векторов, так и для
списков.

\section{Векторы}

Векторы~--- основной тип коллекций с доступом по целочисленному индексу в Common Lisp, и они
имеют две разновидности.  Векторы с фиксированным размером похожи на массивы в языках,
подобных Java: простая надстройка над непрерывной областью памяти, хранящей элементы
вектора\footnote{Векторы называются векторами, а не массивами, в отличие от их аналогов в других
  языках программирования, так как Common Lisp поддерживает настоящие многомерные
  массивы.  Одинаково корректно (хотя и несколько неуклюже) ссылаться на них как на
  \textit{одномерные массивы} (\textit{one-dimensional arrays}).}. С другой стороны,
векторы с изменяемым размером более похожи на векторы в Perl или Ruby, списки в Python
или на класс \code{ArrayList} в Java: они скрывают конкретный способ хранения, позволяя
векторам менять размер по мере добавления или удаления элементов.

Вы можете создать вектор фиксированной длины, содержащий конкретные значения, с помощью
функции \code{VECTOR}, которая принимает любое количество аргументов и возвращает
новый вектор фиксированного размера, содержащий переданные значения.

\begin{lstlisting}[style=lisprepl]
  (vector)     ==> #()
  (vector 1)   ==> #(1)
  (vector 1 2) ==> #(1 2)
\end{lstlisting}

Синтаксис \lstinline!#(...)!~--- способ записи векторов, используемый процедурами
записи и чтения Lisp.  Этот синтаксис позволяет вам сохранять и загружать векторы,
выводя их на печать с помощью \code{PRINT} и считывая с помощью \code{READ}.
Вы можете использовать синтаксис \lstinline!#(...)! для
записи векторных литералов в вашем коде, но поскольку эффект изменения литералов не определён,
то для создания векторов, которые планируется изменять, вы всегда должны 
использовать \code{VECTOR} или более общую функцию \code{MAKE-ARRAY}.

\code{MAKE-ARRAY}~--- более общая функция, чем \code{VECTOR}, поскольку её можно
применять для создания массивов любой размерности, а также для создания векторов
фиксированной и изменяемой длины. Единственным обязательным аргументом \code{MAKE-ARRAY}
является список, содержащий размерности массива.  Поскольку вектор~--- одномерный массив,
то список будет содержать только одно число~--- размер вектора.  Для удобства
\code{MAKE-ARRAY} может также принимать обычное число вместо списка из одного элемента.
Без предоставления дополнительных аргументов \code{MAKE-ARRAY} создаст вектор с
неинициализированными элементами, которые перед использованием будет необходимо
проинициализировать\footnote{Элементы массива <<должны>> быть заданы до того, как вы будете осуществлять
  доступ к ним, поскольку иначе поведение будет неопределённым; Lisp не обязан
  останавливать вас при совершении ошибок.}.  Для создания вектора, с присвоением всем
элементам определённого значения, вы можете использовать аргумент \code{:initial-element}.
Таким образом, создать вектор из пяти элементов, равных \code{NIL}, можно так:

\begin{lstlisting}[style=lisprepl]
  (make-array 5 :initial-element nil) ==> #(NIL NIL NIL NIL NIL)
\end{lstlisting}

\code{MAKE-ARRAY} также используется для создания векторов переменного размера.
Вектор с изменяемым размером несколько сложнее, чем вектор фиксированного размера;
помимо количества доступных ячеек и области памяти, выделенной под хранение элементов,
вектор с изменяемым размером также отслеживает, сколько элементов фактически
хранится в векторе.  Это число хранится в \textit{указателе заполнения} (\textit{fill pointer})
вектора, названного так, поскольку это индекс позиции, которая будет заполнена следующей,
когда вы добавите элемент в вектор.

Чтобы создать вектор с указателем заполнения, вы должны передать \code{MAKE-ARRAY}
аргумент \code{:fill-pointer}.  Например, следующий вызов \code{MAKE-ARRAY} создаст вектор
с местом для пяти элементов; но он будет выглядеть пустым, поскольку указатель заполнения
равен нулю:

\begin{lstlisting}[style=lisprepl]
  (make-array 5 :fill-pointer 0) ==> #()
\end{lstlisting}

Чтобы добавить элемент в конец вектора, можно использовать функцию
\code{VECTOR-PUSH}.  Она добавляет элемент в позицию, указываемую указателем заполнения, и
затем увеличивает его на единицу, возвращая индекс ячейки, куда был добавлен новый
элемент.  Функция \code{VECTOR-POP} возвращает последний добавленный элемент, уменьшая
указатель заполнения на единицу.

\begin{lstlisting}[style=lisprepl]
  (defparameter *x* (make-array 5 :fill-pointer 0))
  
  (vector-push 'a *x*) ==> 0
  *x*                  ==> #(A)
  (vector-push 'b *x*) ==> 1
  *x*                  ==> #(A B)
  (vector-push 'c *x*) ==> 2
  *x*                  ==> #(A B C)
  (vector-pop *x*)     ==> C
  *x*                  ==> #(A B)
  (vector-pop *x*)     ==> B
  *x*                  ==> #(A)
  (vector-pop *x*)     ==> A
  *x*                  ==> #()
\end{lstlisting}

Однако даже вектор с указателем заполнения на самом деле не является вектором с изменяемыми
размерами.  Вектор \code{*x*} может хранить максимум пять элементов.  Для того чтобы
создать вектор с изменяемым размером, вам необходимо передать \code{MAKE-ARRAY} другой
именованный аргумент: \code{:adjustable}.

\begin{lstlisting}[style=lisprepl]
  (make-array 5 :fill-pointer 0 :adjustable t) ==> #()
\end{lstlisting}

Этот вызов создаст \textit{приспособляемый} (\textit{adjustable}) вектор, размер которого
может изменяться по мере необходимости.  Чтобы
добавить элементы в такой вектор, вам нужно использовать функцию
\code{VECTOR-PUSH-EXTEND}, которая работает так же, как и \code{VECTOR-PUSH}, однако
она автоматически увеличит массив, если вы попытаетесь добавить элемент в
уже заполненный вектор~--- вектор, чей указатель заполнения равен размеру выделенной
памяти\footnote{Хотя аргументы \code{:fill-pointer} и \code{:adjustable} часто используются
  вместе, но они независимы друг от друга~--- вы можете создать
  массив с изменяемым размером без указателя заполнения.  Однако вы можете использовать
  \code{VECTOR-PUSH} и \code{VECTOR-POP} только с векторами, которые имеют указатель
  заполнения, а \code{VECTOR-PUSH-EXTEND}~--- только с векторами, которые имеют переменный
  размер и указатель заполнения.  Вы также можете использовать функцию \code{ADJUST-ARRAY}
  для изменения параметров массивов переменной длины, а не только изменения длины
  вектора.}.


\section{Подтипы векторов}

Все векторы, с которыми мы уже встречались, были векторами \textit{общего назначения}
(\textit{general}), которые могут хранить объекты любого типа.  Однако возможно и
создание \textit{специализированных} (\textit{specialized}) векторов,
которые предназначены для хранения элементов определённого типа.  Одной из
причин использовать специализированные векторы является то, что они могут требовать
меньше памяти и обеспечивать более быстрый доступ к своим элементам, по сравнению с
векторами общего назначения.  Однако давайте сосредоточимся на некоторых
специализированных векторах, которые сами по себе являются важными типами данных.

С одним из них мы уже встречались: строки~--- это векторы, предназначенные для хранения
знаков.  Строки так важны, что для них предусмотрен собственный синтаксис чтения/записи
(двойные кавычки) и набор отдельных функций, которые мы обсуждали в предыдущей главе.  Но
поскольку они также являются векторами, то все функции, работающие с векторами и которые мы
будем обсуждать в следующих разделах, могут также использоваться для работы со строками.
Эти функции дополнят библиотеку функций работы со строками новыми функциями для таких
операций, как поиск подстроки в строке, нахождение позиции знака в строке и т. п.

Строки, такие как \code{"foo"}, подобны векторам, записанным с использованием синтаксиса
\lstinline!#()!~--- их размер фиксирован, и они не должны изменяться.  Однако вы можете
использовать функцию \code{MAKE-ARRAY} для создания строк с изменяемым размером, просто
добавив ещё один именованный аргумент~--- \code{:element-type}.  Этот аргумент принимает
описание \textit{типа} (\textit{type} descriptor}.  Я не буду тут описывать типы, которые
вы можете использовать; сейчас достаточно знать, что вы можете создать строку, передав символ
\code{CHARACTER} в качестве аргумента \code{:element-type}.  Заметьте, что необходимо экранировать
символ, чтобы он не считался именем переменной.  Например, чтобы создать пустую строку с
изменяемым размером, вы можете написать вот так:

\begin{lstlisting}[style=lisprepl]
  (make-array 5 :fill-pointer 0 :adjustable t :element-type 'character) ==> ""
\end{lstlisting}

Битовые векторы (специализированные векторы, чьи элементы могут иметь значение ноль или
один) также отличаются от обычных векторов.  Они также имеют специальный синтаксис
чтения/записи, который выглядит вот так \lstinline!#*00001111!, а еще достаточно большой
набор функций (которые я не буду тут описывать) для выполнения битовых операций, таких как
выполнение <<и>> для двух битовых массивов.  Для создания такого вектора нужно передать
в качестве \code{:element-type} символ \code{BIT}.

\section{Векторы как последовательности}

Как уже упоминалось ранее, векторы и списки являются подтипами абстрактного типа
\textit{последовательность} (\textit{sequence}).  Все функции, которые будут обсуждаться
в следующих разделах, работают с последовательностями; они могут работать не только с векторами
(и специализированным, и общего назначения), но и со списками.

Две самые простые функции для работы с последовательностями~--- \code{LENGTH},
возвращающая длину последовательности, и \code{ELT}, осуществляющая доступ к
отдельным элементам по целочисленному индексу.  \code{LENGTH} получает
последовательность в качестве единственного аргумента и возвращает число элементов в этой
последовательности.  Для векторов с указателем заполнения это число будет равно значению
указателя. \code{ELT} (сокращение слова \textit{element}) получает два аргумента~---
последовательность и числовой индекс между нулём (включительно) и длиной
последовательности (не включительно)~--- и возвращает соответствующий элемент.  \code{ELT} выдаст ошибку,
если индекс находится за границами последовательности.  Подобно \code{LENGTH}, \code{ELT}
рассматривает вектор с указателем заполнения как имеющий длину, заданную этим
указателем.

\begin{lstlisting}[style=lisprepl]
  (defparameter *x* (vector 1 2 3))
  
  (length *x*) ==> 3
  (elt *x* 0)  ==> 1
  (elt *x* 1)  ==> 2
  (elt *x* 2)  ==> 3
  (elt *x* 3)  ==> error
\end{lstlisting}

\code{ELT} возвращает ячейку, для которой можно выполнить \code{SETF}, так что вы можете
установить значение отдельного элемента с помощью вот такого кода:

\begin{lstlisting}[style=lisprepl]
  (setf (elt *x* 0) 10)
  
  *x* ==> #(10 2 3)
\end{lstlisting}

\section{Функции для работы с элементами последовательностей}

Хотя в теории все операции над последовательностями могут быть сведены к комбинациям
\code{LENGTH}, \code{ELT} и \code{SETF} на результат \code{ELT}, Common Lisp все равно
предоставляет большую библиотеку функций для работы с последовательностями.

Одна группа функций позволит вам выполнить некоторые операции, такие как нахождение или
удаление определённых элементов, без явного написания циклов.  Краткая сводка этих функций
приводится на рис.~\ref{table:11-1}.

\begin{figure}[tb]
\begin{tabular}{|c|p{50mm}|p{55mm}|}
\hline
Название &\multicolumn{1}{c|}{Обязательные аргументы} &\multicolumn{1}{c|}{Возвращаемое значение} \\
\hline
\code{COUNT}       &Объект и последовательность  &Число вхождений в последовательности\\
\code{FIND}        &Объект и последовательность  &Объект или \code{NIL}\\
\code{POSITION}    &Объект и последовательность  &Индекс ячейки в последовательности или \code{NIL}\\
\code{REMOVE}      &Удаляемый объект и последовательность  &Последовательность, из которой удалены указанные объекты\\
\code{SUBSTITUTE}  &Новый объект, заменяемый объект и последовательность &Последовательность, в которой указанные объекты заменены на новые\\
\hline
\end{tabular}
  \caption{Базовые функции для работы с последовательностями} 
  \label{table:11-1}
\end{figure}

Вот несколько простых примеров использования этих функций:

\begin{lstlisting}[style=lisprepl]
  (count 1 #(1 2 1 2 3 1 2 3 4))         ==> 3
  (remove 1 #(1 2 1 2 3 1 2 3 4))        ==> #(2 2 3 2 3 4)
  (remove 1 '(1 2 1 2 3 1 2 3 4))        ==> (2 2 3 2 3 4)
  (remove #\a "foobarbaz")               ==> "foobrbz"
  (substitute 10 1 #(1 2 1 2 3 1 2 3 4)) ==> #(10 2 10 2 3 10 2 3 4)
  (substitute 10 1 '(1 2 1 2 3 1 2 3 4)) ==> (10 2 10 2 3 10 2 3 4)
  (substitute #\x #\b "foobarbaz")       ==> "fooxarxaz"
  (find 1 #(1 2 1 2 3 1 2 3 4))          ==> 1
  (find 10 #(1 2 1 2 3 1 2 3 4))         ==> NIL
  (position 1 #(1 2 1 2 3 1 2 3 4))      ==> 0
\end{lstlisting}

Заметьте, что \code{REMOVE} и \code{SUBSTITUTE} всегда возвращают последовательность
того же типа, что и переданный аргумент.

Вы можете изменить поведение этих функций с помощью различных именованных аргументов.
Например, по умолчанию эти функции ищут в последовательности точно такой же объект, что и
переданный в качестве аргумента.  Вы можете изменить это поведение двумя способами: во-первых,
вы можете использовать именованный аргумент \code{:test} для указания функции,
которая принимает два аргумента и возвращает логическое значение.  Если этот аргумент
указан, то он будет использоваться для сравнения каждого \textit{элемента} с эталонным вместо стандартной
проверки на равенство с помощью \code{EQL}\footnote{Другой именованный параметр,
  \code{:test-not}, указывает предикат, который будет использоваться точно так же, как и
  параметр \code{:test}, но результат будет изменён на
  противоположное значение.  Однако этот параметр считается устаревшим, и предпочтительным
  является использование функции \code{COMPLEMENT}.  \code{COMPLEMENT} получает
  аргумент-функцию и возвращает функцию, которая получает то же самое количество
  аргументов, что и оригинальная, но возвращает результат, имеющий противоположное
  значение результату, возвращаемому оригинальной функцией.  Так что вы можете (и должны)
  писать вот так:

\begin{lstlisting}[style=lisprepl]
  (count x sequence :test (complement #'some-test))
\end{lstlisting}

\noindent{}вместо:

\begin{lstlisting}[style=lisprepl]
  (count x sequence :test-not #'some-test)
\end{lstlisting}

}. Во-вторых, используя именованный параметр \code{:key}, вы можете передать функцию одного
аргумента, с помощью которой из каждого элемента последовательности будет извлекаться \textit{ключ},
который затем будет сравниваться с переданным объектом.  Однако заметьте, что
функции (например, \code{FIND}), возвращающие элементы последовательности, все равно будут
возвращать элементы, а не ключи, извлечённые из этих элементов.

\begin{lstlisting}[style=lisprepl]
  (count "foo" #("foo" "bar" "baz") :test #'string=)    ==> 1
  (find 'c #((a 10) (b 20) (c 30) (d 40)) :key #'first) ==> (C 30)
\end{lstlisting}

Для ограничения действия этих функций в рамках только определённых пределов вы можете
указать граничные индексы, используя именованные аргументы \code{:start} и \code{:end}.
Передача \code{NIL} в качестве значения \code{:end} (или его полное отсутствие)
равносильно указанию длины последовательности\footnote{Заметьте, однако, что для
  \code{REMOVE} и \code{SUBSTITUTE} указание \code{:start} и \code{:end} приводит к
  ограничению количества аргументов, подпадающих под удаление или замену; элементы до
  \code{:start} и после \code{:end} будут переданы без изменений.}.

Если указывается не равный \code{NIL} аргумент \code{:from-end}, то элементы
последовательности проверяются в обратном порядке.  Простое указание \code{:from-end}
может затронуть результаты \code{FIND} и \code{POSITION}.  Например:

\begin{lstlisting}[style=lisprepl]
  (find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first)             ==> (A 10)
  (find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first :from-end t) ==> (A 30)
\end{lstlisting}

Также использование \code{:from-end} может влиять на работу \code{REMOVE} и
\code{SUBSTITUTE} при использовании с другим именованным параметром~--- \code{:count},
который применяется для указания количества заменяемых или удаляемых элементов.  Если вы
указываете \code{:count} меньший, чем количество совпадающих элементов, то результат будет
зависеть от того, с какого конца последовательности вы начинаете обработку:

\begin{lstlisting}[style=lisprepl]
  (remove #\a "foobarbaz" :count 1)             ==> "foobrbaz"
  (remove #\a "foobarbaz" :count 1 :from-end t) ==> "foobarbz"
\end{lstlisting}

И хотя \code{:from-end} не может изменить результат функции \code{COUNT}, его
использование может влиять на порядок элементов, передаваемых функциям, указанным в
параметрах \code{:test} и \code{:key}, которые, возможно, могут вызвать побочные эффекты.
Например:

\begin{lstlisting}[style=lisprepl]
  CL-USER> (defparameter *v* #((a 10) (b 20) (a 30) (b 40)))
  *V*
  CL-USER> (defun verbose-first (x) (format t "Looking at ~s~%" x) (first x))
  VERBOSE-FIRST
  CL-USER> (count 'a *v* :key #'verbose-first)
  Looking at (A 10)
  Looking at (B 20)
  Looking at (A 30)
  Looking at (B 40)
  2
  CL-USER> (count 'a *v* :key #'verbose-first :from-end t)
  Looking at (B 40)
  Looking at (A 30)
  Looking at (B 20)
  Looking at (A 10)
  2
\end{lstlisting}

На рис.~\ref{table:11-2} приведены описания всех стандартных аргументов.

\begin{figure}[tb]
\begin{tabular}{|c|p{87mm}|>{\centering}p{20mm}|}
\hline
Аргумент  &\multicolumn{1}{c|}{Описание}   &Значение по умолчанию\\
\hline
\code{:test}  &Функция двух аргументов, используемая для сравнения элементов (или их ключей, извлечённых функцией \code{:key}) с указанным объектом  &\code{EQL}\\
\code{:key} &Функция одного аргумента, используемая для извлечения ключа из элемента последовательности.  \code{NIL} указывает на использование самого элемента &\code{NIL}\\
\code{:start}  &Начальный индекс (включительно) обрабатываемой последовательности  &\code{0}\\
\code{:end}  &Конечный индекс (не включительно) обрабатываемой последовательности.  \code{NIL} указывает на конец последовательности &\code{NIL}\\
\code{:from-end}  &Если имеет истинное значение, то последовательность будет обрабатываться в обратном порядке, от конца к началу &\code{NIL}\\
\code{:count} &Число, указывающее количество удаляемых или заменяемых элементов, или \code{NIL} для всех элементов (только для \code{REMOVE} и \code{SUBSTITUTE}) &\code{NIL}\\
\hline
\end{tabular}
  \caption{Стандартные именованные аргументы функций работы с последовательностями} 
  \label{table:11-2}
\end{figure}

\section{Аналогичные функции высшего порядка}

Для каждой из функций, которая была описана выше, Common Lisp также предоставляет два
набора \textit{функций высшего порядка} (\textit{higher-order functions}), которые вместо
аргумента, используемого для сравнения,
получают функцию, которая вызывается для каждого элемента последовательности.  Первый
набор функций имеет те же имена, что и функции из базового набора, но с добавлением
суффикса \code{-IF}.  Эти функции подсчитывают, ищут, удаляют и заменяют элементы, для
которых аргумент-функция возвращает истинное значение.  Другой набор функций отличается
тем, что использует суффикс \code{-IF-NOT}, и выполняет те же операции, но для элементов,
для которых функция \textit{не} возвращает истинного значения.

\begin{lstlisting}[style=lisprepl]
  (count-if #'evenp #(1 2 3 4 5))         ==> 2

  (count-if-not #'evenp #(1 2 3 4 5))     ==> 3

  (position-if #'digit-char-p "abcd0001") ==> 4

  (remove-if-not #'(lambda (x) (char= (elt x 0) #\f))
    #("foo" "bar" "baz" "foom")) ==> #("foo" "foom")
\end{lstlisting}

В соответствии со стандартом языка функции с суффиксом \code{-IF-NOT} являются
устаревшими.  Однако это требование само считается неразумным.  Если стандарт будет
пересматриваться, то, скорее, будет удалено это требование, а не функции с суффиксом
\code{-IF-NOT}.  Для некоторых вещей \code{REMOVE-IF-NOT} может использоваться чаще, чем
\code{REMOVE-IF}.  За исключением своего отрицательно звучащего имени, в действительности
\code{REMOVE-IF-NOT} является положительной функцией~--- она возвращает элементы, которые
соответствуют предикату\footnote{Эта функция обеспечивает ту же функциональность, что и
  \code{grep} в Perl и \code{filter} в Python.}.

Оба варианта функций принимают те же именованные аргументы, что и базовые функции, за
исключением аргумента \code{:test}, который не нужен, поскольку главный аргумент сам
является функцией\footnote{Отличием предиката, передаваемого аргументу \code{:test}, от
  аргумента-функции, передаваемого в функции с суффиксами \code{-IF} и \code{-IF-NOT},
  является то, что предикат параметра \code{:test} имеет два аргумента и используется для
  сравнения элементов последовательности с конкретным объектом, в то время как предикаты
  для функций с суффиксами \code{-IF} и \code{-IF-NOT} имеют один аргумент и используются
  для проверки только элементов последовательности.  Если бы базовые варианты не
  существовали, то вы могли бы реализовать их с помощью функций с суффиксом \code{-IF}
  путём указания объекта в функции-предикате.

\begin{lstlisting}[style=lisprepl]
  (count char string) ===
    (count-if #'(lambda (c) (eql char c)) string)
  
  (count char string :test #'CHAR-EQUAL) ===
    (count-if #'(lambda (c) (char-equal char c)) string)
\end{lstlisting}

}.  При указании аргумента \code{:key} функции передаётся значение, извлечённое функцией
аргумента \code{:key}, а не сам элемент.

\begin{lstlisting}[style=lisprepl]
  (count-if #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first)     ==> 2

  (count-if-not #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first) ==> 3

  (remove-if-not #'alpha-char-p
    #("foo" "bar" "1baz") :key #'(lambda (x) (elt x 0))) ==> #("foo" "bar")
\end{lstlisting}

Семейство функций \code{REMOVE} также имеет четвёртый вариант, функцию
\code{REMOVE-DUPLICATES}, которая имеет один аргумент~--- последовательность, из которой
удаляются все, кроме одного экземпляра, каждого дублированного элемента.  Она может
принимать те же самые именованные аргументы, что и \code{REMOVE}, за исключением
\code{:count}, поскольку она всегда удаляет все дубликаты.

\begin{lstlisting}[style=lisprepl]
  (remove-duplicates #(1 2 1 2 3 1 2 3 4)) ==> #(1 2 3 4)
\end{lstlisting}

\section{Работа с последовательностью целиком}

Несколько функций оперируют над последовательностями целиком.  Обычно
они проще, чем функции, которые я описывал ранее.  Например,
\code{COPY-SEQ} и \code{REVERSE} получают по одному аргументу~--- последовательности~--- и
возвращают новую последовательность того же самого типа.  Последовательность, возвращённая
\code{COPY-SEQ}, содержит те же самые элементы, что и исходная,
а последовательность, возвращённая \code{REVERSE}, содержит те же
самые элементы, но в обратном порядке.  Заметьте, что ни одна из этих функций не копирует
сами элементы, заново создаётся только возвращаемая последовательность.

Функция \code{CONCATENATE} создаёт новую последовательность, содержащую объединение произвольного
числа последовательностей.  Однако, в отличие от \code{REVERSE} и \code{COPY-SEQ}, которые
просто возвращают последовательность того же типа, что и переданный аргумент, функции
\code{CONCATENATE} должно быть явно указано, какой тип последовательности необходимо
создать в том случае, если её аргументы имеют разные типы.  Первым аргументом функции
является описание типа, подобного параметру \code{:element-type} функции \code{MAKE-ARRAY}.
В этом случае, вероятнее всего, вы будете использовать следующие символы для указания типа:
\code{VECTOR}, \code{LIST} или \code{STRING}\footnote{Если вы указываете функции
  \code{CONCATENATE}, что она должна вернуть специализированный вектор, например строку,
  то все элементы аргументов-последовательностей должны иметь тот же тип, что и элементы
  этого вектора.}.  Например:

\begin{lstlisting}[style=lisprepl]
  (concatenate 'vector #(1 2 3) '(4 5 6))    ==> #(1 2 3 4 5 6)
  (concatenate 'list #(1 2 3) '(4 5 6))      ==> (1 2 3 4 5 6)
  (concatenate 'string "abc" '(#\d #\e #\f)) ==> "abcdef"
\end{lstlisting}

\section{Сортировка и слияние}

Функции \code{SORT} и \code{STABLE-SORT} обеспечивают два метода сортировки
последовательности.  Они обе получают последовательность и функцию двух аргументов и
возвращают отсортированную последовательность.

\begin{lstlisting}[style=lisprepl]
  (sort (vector "foo" "bar" "baz") #'string<) ==> #("bar" "baz" "foo")
\end{lstlisting}

Разница между этими функциями заключается в том, что \code{STABLE-SORT} гарантирует, что
она не будет изменять порядок элементов, которые считаются эквивалентными, в то время как
\code{SORT} гарантирует только, что результат будет отсортирован, так что некоторые
эквивалентные элементы могут быть поменяны местами.

Обе эти функции представляют собой примеры так называемых \textit{разрушающих} (\textit{destructive}) функций.  Разрушающим
функциям разрешено (обычно в целях эффективности) модифицировать переданные аргументы тем
или иным образом.  Отсюда следуют две вещи: во-первых, вы обязательно должны что-то сделать с
возвращаемым значением этих функций (например, присвоить его переменной или передать его
другой функции), и во-вторых, если вы ещё планируете работать с передаваемым в
разрушающую функцию аргументом, вы должны передавать его копию, а не сам объект.
Я расскажу о разрушающих функциях более подробно в следующей главе.

Обычно после того, как последовательность отсортирована, её неотсортированная версия
больше не нужна, так что имеет смысл
позволить \code{SORT} и \code{STABLE-SORT} разрушать последовательность в процессе её
сортировки.  Но это значит, что вы должны не забывать писать так\footnote{Когда
  передаваемая последовательность является вектором, <<разрушение>> означает изменение
  элементов на месте, так что вы можете обойтись без сохранения возвращаемого значения.
  Однако хорошим стилем будет обязательное использование возвращаемого значения,
  поскольку функции сортировки могут изменять списки произвольным образом.}:

\begin{lstlisting}[style=lisprepl]
  (setf my-sequence (sort my-sequence #'string<))
\end{lstlisting}

\noindent{}вместо:

\begin{lstlisting}[style=lisprepl]
  (sort my-sequence #'string<)
\end{lstlisting}

Обе эти функции принимают именованный аргумент \code{:key}, который, так же как и аргумент
\code{:key} в других функциях работы с последовательностями, должен быть функцией и
использоваться для извлечения значений, которые будут передаваться предикату сортировки
вместо оригинальных элементов.  Извлечённые значения используются только для определения
порядка элементов; возвращённая последовательность будет содержать сами элементы, а не
извлечённые значения.

Функция \code{MERGE} принимает две последовательности и функцию-предикат и возвращает
последовательность, полученную путём слияния двух последовательностей в соответствии с
предикатом.  Она связана с функциями сортировки: если каждая последовательность
уже была отсортирована с использованием того же самого предиката, то и полученная
последовательность также будет отсортирована.  Так же как и функции сортировки,
\code{MERGE} принимает аргумент \code{:key}.  Подобно \code{CONCATENATE}, и по тем же
причинам, первым аргументом \code{MERGE} должно быть описание типа последовательности,
которая будет получена в результате работы.

\begin{lstlisting}[style=lisprepl]
  (merge 'vector #(1 3 5) #(2 4 6) #'<) ==> #(1 2 3 4 5 6)
  (merge 'list #(1 3 5) #(2 4 6) #'<)   ==> (1 2 3 4 5 6)
\end{lstlisting}

\section{Работа с частями последовательностей}

Еще один набор функций позволяет работать с частями последовательностей.  Основная из
таких функций~--- \code{SUBSEQ}, которая выделяет часть последовательности,
начиная с определённого индекса и заканчивая другим индексом или концом
последовательности.  Например:

\begin{lstlisting}[style=lisprepl]
  (subseq "foobarbaz" 3)   ==> "barbaz"
  (subseq "foobarbaz" 3 6) ==> "bar"
\end{lstlisting}

Для результата \code{SUBSEQ} также можно выполнить \code{SETF}, но таким образом нельзя увеличить
или уменьшить последовательность; если часть последовательности и новое значение имеют
разные длины, то более короткое из них определяет то, как много знаков будет изменено.

\begin{lstlisting}[style=lisprepl]
  (defparameter *x* (copy-seq "foobarbaz"))

  (setf (subseq *x* 3 6) "xxx")  ; subsequence and new value are same length
  *x* ==> "fooxxxbaz"

  (setf (subseq *x* 3 6) "abcd") ; new value too long, extra character ignored.
  *x* ==> "fooabcbaz"

  (setf (subseq *x* 3 6) "xx")   ; new value too short, only two characters changed
  *x* ==> "fooxxcbaz"
\end{lstlisting}

Вы можете использовать функцию \code{FILL} для заполнения нескольких значений
последовательности одним и тем же значением.  Обязательные аргументы~---
последовательность и значение, которым нужно заполнить элементы.  По умолчанию
заполняется вся последовательность; вы можете использовать именованные аргументы
\code{:start} и \code{:end} для ограничения границ заполнения.

Если вам нужно найти одну последовательность внутри другой, то вы можете использовать
функцию \code{SEARCH}, которая работает так же, как и функция \code{POSITION}, но первым
аргументом является последовательность, а не единичное значение.

\begin{lstlisting}[style=lisprepl]
  (position #\b "foobarbaz") ==> 3
  (search "bar" "foobarbaz") ==> 3
\end{lstlisting}

Для того чтобы, напротив, найти позицию, в которой две последовательности с общим
префиксом начинают различаться, вы можете использовать функцию \code{MISMATCH}.  Она
принимает две последовательности и возвращает индекс первой пары неравных элементов.

\begin{lstlisting}[style=lisprepl]
  (mismatch "foobarbaz" "foom") ==> 3
\end{lstlisting}

Эта функция возвращает \code{NIL}, если строки совпадают. \code{MISMATCH} может также
принимать стандартные именованные аргументы: аргумент \code{:key} для указания функции
извлечения сравниваемых значений; аргумент \code{:test} для указания функции сравнения и
аргументы \code{:start1}, \code{:end1}, \code{:start2} и :\code{end2} для указания границ
действия внутри последовательностей.  Также указание \code{:from-end} со значением
\code{T} приводит к тому, что поиск осуществляется в обратном порядке, заставляя
\code{MISMATCH} вернуть индекс позиции в первой последовательности, где начинается общий
суффикс последовательностей.

\begin{lstlisting}[style=lisprepl]
  (mismatch "foobar" "bar" :from-end t) ==> 3
\end{lstlisting}

\section{Предикаты для последовательностей}

Также существуют полезные функции \code{EVERY}, \code{SOME}, \code{NOTANY} и
\code{NOTEVERY}, которые пробегают по элементам последовательности, проверяя заданный
предикат.  Первым аргументом всех этих функций является предикат, а остальные аргументы~---
последовательности.  Предикат должен получать столько аргументов, сколько
последовательностей будет передано функциям.  Элементы последовательностей передаются
предикату (по одному элементу за раз), пока не закончатся элементы или не будет выполнено
условие завершения: \code{EVERY} завершается, возвращая ложное значение, сразу, как только это
значение будет возвращено предикатом.  Если предикат всегда возвращает истинное значение,
то функция также вернёт истинное значение.  \code{SOME} возвращает первое не-\code{NIL}
значение, возвращённое предикатом, или возвращает ложное значение, если предикат никогда
не вернул истинного значения. \code{NOTANY} возвращает ложное значение, если предикат
возвращает истинное значение, или истинное, если этого не произошло.  А \code{NOTEVERY}
возвращает истинное значение сразу, как только предикат возвращает ложное значение, или
ложное, если предикат всегда возвращал истинное.  Вот примеры проверок для одной
последовательности:

\begin{lstlisting}[style=lisprepl]
  (every #'evenp #(1 2 3 4 5))    ==> NIL
  (some #'evenp #(1 2 3 4 5))     ==> T
  (notany #'evenp #(1 2 3 4 5))   ==> NIL
  (notevery #'evenp #(1 2 3 4 5)) ==> T
\end{lstlisting}

А эти вызовы выполняют попарное сравнение последовательностей:

\begin{lstlisting}[style=lisprepl]
  (every #'> #(1 2 3 4) #(5 4 3 2))    ==> NIL
  (some #'> #(1 2 3 4) #(5 4 3 2))     ==> T
  (notany #'> #(1 2 3 4) #(5 4 3 2))   ==> NIL
  (notevery #'> #(1 2 3 4) #(5 4 3 2)) ==> T
\end{lstlisting}

\section{Функции отображения последовательностей}

В заключение обзора функций работы с последовательностями рассмотрим
функции отображения (mapping).  Функция \code{MAP}, подобно функциям-предикатам для
последовательностей, получает функцию нескольких аргументов и несколько
последовательностей.  Но вместо логического значения \code{MAP} возвращает новую
последовательность, содержащую результаты применения функции к элементам
последовательности.  Так же как для \code{CONCATENATE} и \code{MERGE}, \code{MAP}
необходимо сообщить тип создаваемой последовательности.

\begin{lstlisting}[style=lisprepl]
  (map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)) ==> #(10 18 24 28 30)
\end{lstlisting}

Функция \code{MAP-INTO} похожа на \code{MAP}, за исключением того, что вместо создания
новой последовательности заданного типа она помещает результаты в последовательность,
заданную в качестве первого аргумента.  Эта последовательность может иметь такой же тип,
как одна из последовательностей, предоставляющих данные для функции.  Например, для
суммирования нескольких векторов (\code{a}, \code{b} и \code{c}) в один вы должны
написать:

\begin{lstlisting}[style=lisprepl]
  (map-into a #'+ a b c)
\end{lstlisting}

Если последовательности имеют разную длину, то \code{MAP-INTO} изменяет столько элементов,
сколько присутствует в самой короткой последовательности, включая ту, в которую помещаются
результаты.  Однако если последовательность будет отображаться в вектор с указателем
заполнения, то число изменяемых элементов будет определяться не указателем заполнения, а
размером вектора.  После вызова \code{MAP-INTO} указатель заполнения будет установлен
равным количеству изменённых элементов. Однако \code{MAP-INTO} не будет изменять размера
векторов, которые допускают такую операцию.

Напоследок рассмотрим функцию \code{REDUCE},
которая реализует другой вид отображения: она выполняет отображение для
одной последовательности, применяя функцию двух аргументов сначала к первым двум элементам
последовательности, а после первого вызова последовательно применяя её к полученному
результату и следующим элементам.  Таким образом, следующее выражение сложит числа от
единицы до десяти:

\begin{lstlisting}[style=lisprepl]
  (reduce #'+ #(1 2 3 4 5 6 7 8 9 10)) ==> 55
\end{lstlisting}

\code{REDUCE}~--- удивительно полезная функция: если вам нужно создать из
последовательности одно значение, вполне вероятно, что вы сможете сделать это с помощью
\code{REDUCE}, и такая запись зачастую оказывается весьма лаконичной.
Например, для нахождения максимального значения в последовательности вы можете просто
написать \lstinline!(reduce #'max numbers)!. \code{REDUCE} также принимает полный набор
стандартных именованных аргументов (\code{:key}, \code{:from-end}, \code{:start} и
\code{:end}), а также один, уникальный для \code{REDUCE} (\code{:initial-value}).  Этот
аргумент указывает значение, которое будет логически помещено до первого элемента
последовательности (или после последнего, если вы также зададите \code{:from-end} истинное
значение).

\section{Хэш-таблицы}

Еще одна коллекция общего назначения в Common Lisp~--- хэш-таблица.  В отличие от векторов,
позволяющих осуществлять доступ по целочисленному индексу,
хэш-таблицы позволяют использовать в качестве индексов (ключей) любые объекты.
Добавляя объекты в хэш-таблицу, вы сохраняете их с определённым ключом.  Позднее вы
можете использовать тот же самый ключ для доступа к значению.  Или вы можете связать
с тем же самым ключом новое значение~--- каждый ключ отображается в единственное значение.

Без указания дополнительных аргументов \code{MAKE-HASH-TABLE} создаёт хэш-таблицу, которая
сравнивает ключи с использованием функции \code{EQL}.  Это нормально до тех пор, пока вы
не захотите использовать в качестве ключей строки, поскольку две строки с одинаковым
содержимым не обязательно равны в терминах \code{EQL}.  В таком случае следует
использовать для сравнения функцию \code{EQUAL}: это можно сделать, передав функции
\code{MAKE-HASH-TABLE} символ \code{EQUAL} в качестве именованного аргумента \code{:test}.
Кроме того, для аргумента \code{:test} можно использовать ещё два символа: \code{EQ} и
\code{EQUALP}.  Конечно, эти символы являются именами стандартных функций сравнения
объектов, которые я обсуждал в главе~\ref{ch:04}.  Однако, в отличие от аргумента \code{:test},
передаваемого функциям работы с последовательностями, аргумент \code{:test} функции
\code{MAKE-HASH-TABLE} не может использовать произвольную функцию~--- допустимы только
значения \code{EQ}, \code{EQL}, \code{EQUAL} и \code{EQUALP}.  Это происходит потому, что
на самом деле хэш-таблице нужны две функции~--- функция сравнения и функция
\textit{хэширования}, которая получает из ключа числовой хэш-код способом, совместимым с
функцией сравнения.  Хотя стандарт языка предоставляет
только хэш-таблицы, использующие стандартные функции сравнения, большинство
реализаций позволяет тем или иным образом создавать более тонко настраиваемые
хэш-таблицы.

Функция \code{GETHASH} обеспечивает доступ к элементам хэш-таблиц.  Она принимает два
аргумента: ключ и хэш-таблицу~--- и возвращает значение, если оно найдено, или \code{NIL} в
противном случае\footnote{По историческим причинам порядок аргументов \code{GETHASH}
  отличается от порядка аргументов функции \code{ELT}~--- \code{ELT} получает коллекцию в
  качестве первого аргумента, а индекс~--- в качестве второго; а \code{GETHASH} наоборот:
  ключ~--- первым, а коллекцию~--- вторым.}.  Например:

\begin{lstlisting}[style=lisprepl]
  (defparameter *h* (make-hash-table))
  (gethash 'foo *h*) ==> NIL
  (setf (gethash 'foo *h*) 'quux)
  (gethash 'foo *h*) ==> QUUX
\end{lstlisting}

Поскольку \code{GETHASH} возвращает \code{NIL}, если ключ не присутствует в таблице, то нет
никакого способа отличить ключ, отсутствующий в таблице, от ключа, по которому хранится
значение \code{NIL}.  Функция \code{GETHASH} решает эту проблему за счёт использования
способа, который мы ещё не обсуждали,~--- возврата нескольких значений.  В действительности
\code{GETHASH} возвращает два значения: главное значение~--- значение для указанного ключа
или \code{NIL};  дополнительное значение имеет логический тип и указывает, присутствует ли
значение в хэш-таблице.  Из-за способа реализации возврата множественных значений
дополнительные значения просто отбрасываются, если только пользователь не обрабатывает эту
ситуацию специальным образом, используя средства, которые <<видят>> множественные значения.

Я буду подробно обсуждать возврат множественных значений в главе~\ref{ch:20}, но сейчас я
дам вам лишь общее представление о том, как использовать макрос \code{MULTIPLE-VALUE-BIND}
для получения дополнительных значений, которые возвращает \code{GETHASH}.  Макрос
\code{MULTIPLE-VALUE-BIND} создаёт привязки переменных, как это делает \code{LET},
заполняя их множеством значений, возвращённых вызываемой функцией.

Следующие примеры показывают, как вы можете использовать \code{MULTIPLE-VALUE-BIND};
связываемые переменные содержат значение и признак его наличия в таблице:

\begin{lstlisting}  
  (defun show-value (key hash-table)
    (multiple-value-bind (value present) (gethash key hash-table)
      (if present
        (format nil "Значение ~a присутствует в таблице." value)
        (format nil "Значение равно ~a, поскольку ключ не найден." value))))

  (setf (gethash 'bar *h*) nil) ; создаёт ключ со значением NIL

  (show-value 'foo *h*) ==> "Значение QUUX присутствует в таблице."
  (show-value 'bar *h*) ==> "Значение NIL присутствует в таблице."
  (show-value 'baz *h*) ==> "Значение равно NIL , поскольку ключ не найден."
\end{lstlisting}

Поскольку установка значения в \code{NIL} оставляет ключ в таблице, вам понадобится другая
функция для полного удаления пары ключ/значение.  Функция \code{REMHASH} получает такие же
аргументы, как и \code{GETHASH}, и удаляет указанную запись.  Вы также можете полностью
очистить хэш-таблицу с помощью функции \code{CLRHASH}.


\section{Функции для работы с записями в хэш-таблицах}

Common Lisp предоставляет разные способы для работы с записями в хэш-таблицах.  Простейшим
из них является использование функции \code{MAPHASH}.  Так же как и функция \code{MAP},
функция \code{MAPHASH} принимает в качестве аргументов функцию двух аргументов и
хэш-таблицу и выполняет указанную функцию для каждой пары ключ/значение.  Например, для
распечатки всех пар ключ/значение вы можете использовать такой вызов \code{MAPHASH}:

\begin{lstlisting}[style=lisprepl]
  (maphash #'(lambda (k v) (format t "~a => ~a~%" k v)) *h*)
\end{lstlisting}

Последствия добавления или удаления записей в хэш-таблице во время прохода по её записям
стандартом не указываются (и скорее всего, окажутся печальными), за исключением двух
случаев: вы можете использовать \code{SETF} вместе с \code{GETHASH} для изменения значения
текущей записи, и вы можете использовать \code{REMHASH} для удаления текущей записи.
Например, для удаления всех записей, чьё значение меньше, чем десять, вы можете записать
вот так:

\begin{lstlisting}[style=lisprepl]
  (maphash #'(lambda (k v) (when (< v 10) (remhash k *h*))) *h*)
\end{lstlisting}

Еще один способ итерации по элементам хэш-таблицы~--- использование макроса
\code{LOOP}, который будет описан в главе~\ref{ch:22}\footnote{Использование \code{LOOP} для
  работы с хэш-таблицами обычно основывается на использовании более примитивной формы,
  \code{WITH-HASH-TABLE-ITERATOR}, о которой вам не нужно беспокоиться; она была добавлена
  в язык специально для поддержки реализации таких вещей, как \code{LOOP}, и практически не
  нужна до тех пор, пока вы не соберётесь реализовать совершенно новый способ итерации по
  элементам хэш-таблиц.}.  С использованием \code{LOOP} код, реализующий то же, что и первый
пример с \code{MAPHASH}, будет выглядеть вот так:

\begin{lstlisting}  
  (loop for k being the hash-keys in *h* using (hash-value v)
    do (format t "~a => ~a~%" k v))
\end{lstlisting}

Я мог бы рассказать еще очень многое о коллекциях, не являющихся списками, в Common
Lisp.  Например, я совсем не рассказал про многомерные массивы или про библиотеку функций
для работы с битовыми массивами.  Однако того, что я рассказал в этой главе, должно быть
достаточно для основных применений.  Теперь пора взглянуть на
структуру данных, давшую имя языку Lisp,~--- списки.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
