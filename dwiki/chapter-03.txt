====== 3. Практикум: Простая база данных ======

Очевидно, перед тем, как создавать настоящие программы на Lisp, вам необходимо изучить язык. Но давайте смотреть правде в глаза --- вы можете подумать "Practical Common Lisp"? Не оксюморон ли это? Зачем тратить силы на изучение деталей языка, если на нем невозможно сделать что-то дельное?". Итак, для начала я приведу маленький пример того, что можно сделать с помощью Common Lisp. В этой главе вы напишете простую базу данных для организации коллекции CD. В главе 27 вы будете использовать схожую технику при создании базы данных записей в формате MP3 для вашего потокового MP3-сервера. Фактически, можете считать это частью вашего программного проекта --- в конце концов, для того, чтобы иметь сколько-нибудь MP3-записей для прослушивания, совсем не помешает знать, какие записи у вас есть, а какие нужно извлечь с диска.
 

В этой главе я пройдусь по языку Lisp достаточно для того, чтобы вы продвинулись до понимания того, каким образом работает код на нём. Но я не буду вдаваться в детали. Вы можете не беспокоиться, если что-то здесь будет вам непонятно --- в нескольких следующих главах все используемые здесь (а также многие другие) конструкции Common Lisp будут описаны гораздо более систематически.

Одно замечание по терминологии: в этой главе я расскажу о некоторых операторах Lisp. В главе 4 вы узнаете, что Common Lisp предоставляет три разных типа операторов: функции, макросы и операторы специального назначения. Для целей этой главы вам необязательно понимать разницу. Однако я буду ссылаться на различные операторы как на функции, макросы или специальные операторы, в зависимости от того, чем они на самом деле являются, вместо того, чтобы попытаться скрыть эти детали за одним словом --- оператор. Сейчас вы можете рассматривать функции, макросы и специальные операторы как более или менее эквивалентные сущности((Прежде, чем я продолжу, очень важно, чтобы вы забыли все, что можете знать о "макросах" в стиле #define, реализованных в препроцессоре C. Макросы Lisp не имеют с ними ничего общего)).

Также имейте ввиду, что я не буду использовать все наиболее сложные техники Common Lisp для вашей первой после "Hello, world" программы. Цель этой главы не в том, чтобы показать, как вам следует писать базу данных на Lisp; скорее, цель в том, чтобы вы получили представление, на что похоже программирование на Lisp и видение того, что даже относительно простая программа на Lisp может иметь много возможностей.

===== CD и Записи =====
Чтобы отслеживать диски, которые нужно перекодировать в MP3, и знать, какие из них должны быть перекодированы в первую очередь, каждая запись в базе данных будет содержать название и имя исполнителя компакт диска, оценку того, насколько он нравится пользователю и флаг, указывающий, был ли диск уже перекодирован. Итак, для начала вам необходим способ представления одной записи в базе данных (другими словами, одного CD). Common Lisp предоставляет для этого много различных структур данных, от простого четырехэлементного списка до определяемого пользователем с помощью CLOS класса данных.

Для начала вы можете остановиться на простом варианте и использовать список. Вы можете создать его с помощью функции ''LIST'', которая, соответственно, возвращает **список** ((''LIST'' --- по английски **СПИСОК**. Кстати, последние реализации Common Lisp позволяют писать и на родном для вас языке. Например, на русском можно создать макрос ''СПИСОК'', который будет вызывать ''LIST'', например так: <code lisp>(defmacro список (&body body) `(list ,@body))</code> //--- Прим. перев.//)) из переданных аргументов.

  CL-USER> (list 1 2 3)
   (1 2 3)

Вы могли бы использовать четырёхэлементный список, отображающий позицию в списке на соответствующее поле записи. Однако другая существующая разновидность списков, называемая //property list// (список свойств) или, сокращенно, //plist//, в нашем случае гораздо удобнее. //Plist// --- это такой список, в котором каждый нечетный элемент является //символом//, описывающим следующий (чётный) элемент списка. На этом этапе я не буду углубляться в подробности понятия //символ//; по своей природе это имя. Для символов, именующих поля в базе данных, мы можем использовать частный случай символов, называемый //символами-ключами// (//keyword symbol//). Ключ --- это имя, начинающееся с двоеточия (:), например, :foo ((''foo'', ''bar'' --- любимые имена переменных у англоговорящих программистов, пишущих книги и документацию //--- Прим. перев.//)). Вот пример //plist//, использующего символы-ключи :a, :b и :c как имена свойств:

  CL-USER> (list :a 1 :b 2 :c 3)
  (:A 1 :B 2 :C 3)

Заметьте, вы можете создать список свойств той же функцией ''LIST'', которой создавали прочие списки. Характер содержимого --- вот что делает его списком свойств.

Причина, по которой использование //plist// является предпочтительным --- наличие функции ''GETF'', в которую передают //plist// и желаемый символ и получают следующее за символом значение. Это делает //plist// чем-то вроде упрощенной хэш-таблицы. В Lisp есть и "настоящие" хэш-таблицы, но для ваших текущих нужд достаточно //plist//, к тому же намного проще сохранять данные в такой форме в файл, это сильно пригодится позже.

  CL-USER> (getf (list :a 1 :b 2 :c 3) :a)
  1
  CL-USER> (getf (list :a 1 :b 2 :c 3) :c)
  3

Теперь, зная это, вам будет достаточно просто написать функцию ''make-cd'', которая получит четыре поля в качестве аргументов и вернёт //plist//, представляющий CD.
<code lisp>
(defun make-cd (title artist rating ripped)
  (list :title title :artist artist :rating rating :ripped ripped))
</code>

Слово ''DEFUN'' говорит нам,((Тем, для кого английский родной //--- Прим. перев.//)) что эта запись определяет новую функцию. Имя функции --- ''make-cd''. После имени следует список параметров. Функция содержит четыре параметра --- ''title'', ''artist'', ''rating'' и ''ripped''. Всё, что следует за списком параметров --- тело функции. В данном случае //тело// --- лишь форма, просто вызов функции **LIST**. При вызове ''make-сd'' параметры, переданные при вызове, будут связаны с переменными в списке параметров из объявления функции. Например, для создания записи о CD //Roses// от Kathy Mattea вы можете вызвать ''make-cd'' примерно так:

   CL-USER> (make-cd "Roses" "Kathy Mattea" 7 t)
   (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T) 

===== Заполнение CD =====
Впрочем, создание одной записи --- ещё не создание базы данных. Вам необходима более комплексная структура данных для хранения записей. Опять же, простоты ради, список представляется здесь вполне подходящим выбором. Также для простоты вы можете использовать глобальную переменную *db*, которую можно будет определить с помощью макроса **DEFVAR**. Звездочки (*) в имени переменной --- это договоренность, принятая в языке Lisp при объявлении глобальных переменных. ((Использование глобальной переменной имеет ряд недостатков --- например, вы можете использовать только одну базу данных в каждый момент времени. В гл. 27, имея за плечами уже солидный багаж знаний о Lisp, вы будете готовы к созданию более гибкой базы данных. В 6 главе вы также увидите, что даже использование глобальных переменных в Common Lisp более гибко, чем это возможно в других языках.)) 
<code lisp>
(defvar *db* nil)
</code>
Для добавления элементов в *db* можно использовать макрос **PUSH**. Но разумнее немного абстрагировать вещи и определить функцию 'add-record', которая будет добавлять записи в базу данных.
<code lisp>
(defun add-record (cd) (push cd *db*))
</code>
Теперь вы можете использовать ''add-record'' вместе с ''make-cd'' для добавления CD в базу данных.

   CL-USER> (add-record (make-cd "Roses" "Kathy Mattea" 7 t))
   ((:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
   CL-USER> (add-record (make-cd "Fly" "Dixie Chicks" 8 t))
   ((:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
    (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
   CL-USER> (add-record (make-cd "Home" "Dixie Chicks" 9 t))
   ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
    (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
    (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T)) 

Всё, что REPL выводит после каждого вызова ''add-record'' --- значения, возвращаемые последним выражением в теле функции, в нашем случае --- ''PUSH''. А ''PUSH'' возвращает новое значение изменяемой им переменной. Таким образом, после каждого добавления порции данных вы видите содержимое вашей базы данных.
===== Просмотр содержимого базы данных =====
Вы также можете просмотреть текущее значение *db* в любой момент, набрав *db* в REPL.

  CL-USER> *db*
  ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
   (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))

Правда, это не лучший способ просмотра данных. Вы можете написать функцию ''dump-db'', которая выводит содержимое базы данных в более читабельной форме, например, так:

   TITLE:    Home
   ARTIST:   Dixie Chicks
   RATING:   9
   RIPPED:   T
   
   TITLE:    Fly
   ARTIST:   Dixie Chicks
   RATING:   8
   RIPPED:   T
   
   TITLE:    Roses
   ARTIST:   Kathy Mattea
   RATING:   7
   RIPPED:   T

Эта функция может выглядеть так:
<code lisp>
(defun dump-db ()
  (dolist (cd *db*)
    (format t "~{~a:~10t~a~%~}~%" cd)))
</code>
Работа функции заключается в циклическом обходе всех элементов *db* с помощью макроса **DOLIST**, связывая на каждой итерации каждый элемент с переменной ''cd''. Для вывода на экран каждого значения ''cd'' используется функция ''FORMAT''.

Следует признать, вызов ''FORMAT'' выглядит немного загадочно. Но в действительности ''FORMAT'' не особенно сложнее, чем функция //printf// из **С** или **Perl** или оператор % из **Python**. В главе 18 я расскажу о ''FORMAT'' более подробно. Теперь же давайте шаг за шагом рассмотрим, как работает этот вызов. Как было показано в гл. 2, ''FORMAT'' принимает по меньшей мере два аргумента, первый из которых --- поток, в который ''FORMAT'' направляет свой вывод; **t** --- сокращённое обозначение потока *standard-output*.

Второй аргумент ''FORMAT'' --- формат строки; он может как содержать символьный текст, так и управляющие команды, контролирующие работу этой функции, например то, как она должна интерпретировать остальные аргументы. Команды, управляющие форматом вывода, начинаются со знака тильды (**~**) (так же, как управляющие команды //printf// начинаются с %). ''FORMAT'' может принимать довольно много таких команд, каждую со своим набором параметров((Одна из наиболее "классных" управляющих команд ''FORMAT'' --- команда ~R. Всегда хотели знать, как по-английски произносится //действительно большое// число? Lisp знает. Сделайте так:
<code lisp>
(format nil "~r" 1606938044258990275541962092)
</code>
и вы получите (разбито на строки для удобочитаемости):
"one octillion six hundred six septillion nine hundred thirty-eight sextillion forty-four quintillion two hundred fifty-eight quadrillion nine hundred ninety trillion two hundred seventy-five billion five hundred forty-one million nine hundred sixty-two thousand ninety-two")). Однако сейчас я сфокусируюсь только на тех управляющих командах, которые необходимы для написания функции ''dump-db''.

Команда **~a** служит для придания выводимым строкам некоторой эстетичности. Она принимает аргумент и возвращает его в удобочитаемой форме. Эта команда отобразит ключевые слова без предваряющего двоеточия, и строки --- без кавычек. Например:

  CL-USER> (format t "~a" "Dixie Chicks")
  Dixie Chicks
  NIL

или:

  CL-USER> (format t "~a" :title)
  TITLE
  NIL


Команда **~t** предназначена для табулирования. Например, //~10t// указывает ''FORMAT'', что необходимо выделить достаточно места для перемещения в десятый столбец перед выполнением команды //~a//. //~t// не принимает аргументов. 

  CL-USER> (format t "~a:~10t~a" :artist "Dixie Chicks")
  ARTIST:   Dixie Chicks
  NIL


Теперь рассмотрим немного более сложные вещи. Когда ''FORMAT'' обнаруживает //~{//, следующим аргументом должен быть список. ''FORMAT'' циклично просматривает весь список, на каждой итерации выполняя команды между //~{// и //~}// и используя столько элементов списка, сколько нужно для вывода согласно этим командам. В функции ''dump-db'' ''FORMAT'' будет циклично просматривать список и на каждой итерации принимать одно ключевое слово и одно значение списка. Команда **~%** не принимает аргументов, но заставляет ''FORMAT'' выполнять переход на новую строку. После выполнения команды **~}** итерация заканчивается, и последняя //~%// заставляет ''FORMAT'' сделать ещё один переход на новую строку, чтобы записи, соответствующие каждому CD, были разделены.
Формально, вы также можете использовать ''FORMAT'' для вывода именно базы данных, сократив тело функции ''dump-db'' до одной строки.
<code lisp>
(defun dump-db ()
  (format t "~{~{~a:~10t~a~%~}~%~}" *db*))
</code>

Это выглядит очень круто или очень страшно в зависимости от того как посмотреть.






===== Улучшение взаимодействия с пользователем =====
Хотя функция ''add-record'' прекрасно выполняет свои обязанности, она слишком необычна для пользователя, не знакомого с Lisp. И если он захочет добавить в базу данных несколько записей, это может показаться ему довольно неудобным. В этом случае вы возможно захотите написать функцию, которая будет запрашивать у пользователя информацию о нескольких CD. В этом случае, вам нужен какой-то способ запросить эту информацию у пользователя и считать её. Для этого создадим следующую функцию:
<code lisp>
(defun prompt-read (prompt)
 (format *query-io* "~a: " prompt)
 (force-output *query-io*)
 (read-line *query-io*))
</code>

Мы использовали уже знакомую нам функцию ''FORMAT'', чтобы вывести приглашение. Заметим, что в строке, описывающей формат, отсутствует <<~%", поэтому перевода курсора на новую строку не происходит. Вызов **FORCE-OUTPUT** необходим в некоторых реализациях для уверенности в том, что Lisp не будет ожидать вывода новой строки перед выводом приглашения.

Теперь прочитаем одну строку текста с помощью (очень удачно названной!) функции **READ-LINE**. Переменная ''*QUERY-IO*'' является глобальной (о чем можно догадаться по наличию в её имени символов ''*''), она содержит входной поток, связанный с терминалом. Значение, возвращаемое функцией **PROMPT-READ** --- это значение последней ее формы, вызова ''READ-LINE'', возвращающего прочитанную им строку (без завершающего символа новой строки).

Вы можете скомбинировать уже существующую функцию ''make-cd'' с ''prompt-read'', чтобы построить функцию создания новой записи о CD из данных, которые ''make-cd'' по очереди получает для каждого значения.
<code lisp>
(defun prompt-for-cd ()
 (make-cd
  (prompt-read "Title")
  (prompt-read "Artist")
  (prompt-read "Rating")
  (prompt-read "Ripped [y/n]")))
</code>

Это почти правильно, если не считать того, что функция ''prompt-read'' возвращает строку. Это хорошо подходит для полей Title и Artist, но значения полей Rating и Ripped --- числовое и булево. В зависимости от того, насколько развитым вы хотите сделать пользовательский интерфейс, можете проверять подстроки произвольной длины, чтобы удостовериться в корректности введённых пользователем данных. Теперь давайте опробуем самый очевидный (хотя и не лучший) вариант: мы можем упаковать вызов ''prompt-read'', запрашивающий у пользователя его оценку диска, в вызов специфичной для Lisp функции **PARSE-INTEGER**. Это можно сделать так:
<code lisp>
(parse-integer (prompt-read "Rating"))
</code>

К сожалению, по умолчанию функция ''PARSE-INTEGER'' сообщает об ошибке, если ей не удаётся разобрать число из введённой строки, или если в строке присутствует "нечисловой" мусор. Однако она может принимать дополнительный параметр :junk-allowed, который позволит нам ненадолго расслабиться.
<code lisp>
(parse-integer (prompt-read "Rating") :junk-allowed t)
</code>

Остается ещё одна проблема --- если ''PARSE-INTEGER'' не удастся выделить число среди "мусорных" данных, она вернёт не число, а ''NIL''. Следуя нашему подходу "сделать просто, пусть даже не совсем правильно", мы в этом случае можем просто задать 0 и продолжить. Макрос **OR** здесь --- как раз то, что нужно. Это то же самое, что и операция **||** в Perl, Python, Java и C. Макрос принимает набор выражений и вычисляет их по одному, слева направо. Если какое-нибудь из них дает истинное значение, то оно возвращается как результат макроса **OR**, а остальные --- не вычисляются. Если все выражения оказываются ложными, тогда макрос **OR** возвращает ложь (''NIL''). Таким образом, используем следующую запись:
<code lisp>
(or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
</code>
чтобы получить 0 в качестве значения по умолчанию.

Исправление кода для запроса состояния Ripped немного проще. Можно воспользоваться стандартной функцией Common Lisp **Y-OR-N-P**.
<code lisp>
(y-or-n-p "Ripped [y/n]: ")
</code>

Фактически, этот вызов является самой отказоустойчивой частью ''prompt-for-cd'', поскольку **Y-OR-N-P** будет повторно запрашивать у пользователя состояние флага Ripped, если он введет что-нибудь, начинающееся не с //y//, //Y//, //n// или //N//.

Собрав код вместе, получим достаточно надёжную функцию ''prompt-for-cd'':
<code lisp>
(defun prompt-for-cd ()
  (make-cd
   (prompt-read "Title")
   (prompt-read "Artist")
   (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
   (y-or-n-p "Ripped [y/n]: ")))
</code>

Наконец, мы можем закончить интерфейс добавления CD, упаковав ''prompt-for-cd'' в функцию, циклично запрашивающую пользователя о новых данных. Воспользуемся простой формой макроса **LOOP**, выполняющего выражения в своём теле до тех пор, пока его выполнение не будет прервано вызовом **RETURN**. Например:
<code lisp>
(defun add-cds ()
  (loop (add-record (prompt-for-cd))
      (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
</code>

Теперь с помощью ''add-cds'' добавим в базу несколько новых дисков.

  CL-USER> (add-cds)
  Title: Rockin' the Suburbs
  Artist: Ben Folds
  Rating: 6
  Ripped  [y/n]: y
  Another?  [y/n]: y
  Title: Give Us a Break
  Artist: Limpopo
  Rating: 10
  Ripped  [y/n]: y
  Another?  [y/n]: y
  Title: Lyle Lovett
  Artist: Lyle Lovett
  Rating: 9
  Ripped  [y/n]: y
  Another?  [y/n]: n
  NIL



===== Сохранение и загрузка базы данных =====
Хорошо иметь удобный способ добавления записей в базу данных. Но пользователю вряд ли понравится заново добавлять все записи после каждого перезапуска Lisp. К счастью, используя текущие структуры данных, используемые для представления информации, сохранить данные в файл и загрузить их позже --- задача тривиальная. Далее приводится функция ''save-db'', которая принимает в качестве параметра имя файла и сохраняет в него текущее состояние базы данных:
<code lisp>
(defun save-db (filename)
  (with-open-file (out filename
                   :direction :output
                   :if-exists :supersede)
    (with-standard-io-syntax
      (print *db* out))))
</code>

Макрос **WITH-OPEN-FILE** открывает файл, связывает поток с переменной, выполняет набор инструкций и затем закрывает файл. Он также гарантирует, что файл обязательно закроется, даже если во время выполнения тела макроса что-то пойдет не так. Список, находящийся сразу после **WITH-OPEN-FILE**, является не вызовом функции, а частью синтаксиса, определяемого этим макросом. Он содержит имя переменной, хранящей файловый поток, в который в теле макроса **WITH-OPEN-FILE** будет вестись запись, значение, которое должно быть именем файла, и несколько параметров, управляющих режимом открытия файла. В нашем примере файл будет открыт для записи (задаётся параметром '':direction'' '':output''), и, если файл с таким именем уже существует, его содержимое будет перезаписано (параметр '':if-exists'' '':supersede'').

После того, как файл открыт, всё, что вам нужно --- это печать содержимого базы данных с помощью ''(print *db* out)''. В отличие от **FORMAT**, функция **PRINT** печатает объекты Lisp в форме, которую Lisp может прочитать. Макрос **WITH-STANDARD-IO-SYNTAX** гарантирует, что переменным, влияющим на поведение функции **PRINT**, присвоены стандартные значения. Используйте этот же макрос и при чтении данных из файла для гарантии совместимости операций записи и чтения.

Аргументом функции ''save-db'' должна являться строка, содержащая имя файла, в который пользователь хочет сохранить базу данных. Точный формат строки зависит от используемой операционной системы. Например, в Unix пользователь может вызвать функцию ''save-db'' таким образом:

  CL-USER> (save-db "~/my-cds.db")
  ((:TITLE "Lyle Lovett" :ARTIST "Lyle Lovett" :RATING 9 :RIPPED T)
   (:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T)
   (:TITLE "Rockin' the Suburbs" :ARTIST "Ben Folds" :RATING 6 :RIPPED T)
   (:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
   (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 9 :RIPPED T))


В Windows имя файла может выглядеть так: ''c:/my-cds.db''. Или так: ''c:\\my-cds.db''((На самом деле, Windows позволяет использовать косую черту ("прямые слэши") в именах файлов, хотя в качестве разделителей имён директорий в этой ОС обычно используются обратные косые ("обратные слэши"). Это очень удобно, ведь иначе вам каждый раз приходилось бы дублировать обратную косую черту, так как это --- Escape-символ в строках Lisp.)).

Вы можете открыть этот файл в любом текстовом редакторе и посмотреть как выглядят записи. Вы должны увидеть что-то очень похожее на вывод REPL если наберёте ''*db*''.

Функция загрузки базы данных из файла реализуется аналогично:
<code lisp>
(defun load-db (filename)
  (with-open-file (in filename)
    (with-standard-io-syntax
      (setf *db* (read in)))))
</code>

В этот раз нет необходимости задавать '':direction'' в параметрах ''WITH-OPEN-FILE'', так как её значение по умолчанию --- '':input''. И вместо печати вы используете функцию **READ** для чтения из потока ''in''. Это тот же считыватель, что и в REPL, и он может прочитать любое выражение на Lisp, которое можно написать в строке приглашения REPL. Однако, в нашем случае, вы просто читаете и сохраняете выражение, не выполняя его. И снова, макрос ''WITH-STANDARD-IO-SYNTAX'' гарантирует, что ''READ'' использует тот же базовый синтаксис, что и функция ''save-db'', когда она печатает данные с помощью ''PRINT''.

Макрос **SETF** является главным оператором присваивания в Common Lisp. Он присваивает свому первому аргументу результат вычисления второго аргумента. Таким образом, в ''load-db'' переменная ''*db*'' будет содержать объект, прочитанный из файла, а именно, список списков, записанных функцией ''save-db''. Обратите внимание на то, что ''load-db'' затирает то, что было в ''*db*'' до её вызова. Так что, если вы добавили записи, используя ''add-records'' или ''add-cds'', и не сохранили их функцией ''save-db'', эти записи будут потеряны.

===== Выполнение запросов к базе данных =====
Теперь, когда у вас есть способ сохранения и загрузки базы данных вместе с удобным интерфейсом для добавления новых записей, ваша коллекция в скором времени может разрастись до такого размера, что вы уже не захотите распечатывать всю базу данных лишь для того, чтобы просмотреть её содержимое. Вам нужно как-то выполнять запросы к базе данных. Возможно, что вы предпочли бы написать что-нибудь вроде:

  (select :artist "Dixie Chicks")

и в ответ на этот запрос получить список всех записей исполнителя Dixie Chicks. И снова оказалось, что выбор списка в качестве контейнера данных был очень удачным.

Функция **REMOVE-IF-NOT** принимает предикат и список в качестве параметров и возвращает список, содержащий только элементы исходного списка, удовлетворяющие предикату. Другими словами, она удаляет все элементы, не удовлетворяющие предикату. На самом деле, ''REMOVE-IF-NOT'' ничего не удаляет --- она создает новый список, оставляя исходный список нетронутым. Эта операция аналогична работе утилиты grep. Предикатом может быть любая функция, принимающая один аргумент и возвращающая логическое значение --- ''NIL'' (ложь) или любое другое значение (истина).

Например, если вы хотите получить все чётные элементы из списка чисел, можете использовать ''REMOVE-IF-NOT'' таким образом:

  CL-USER> (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10))
  (2 4 6 8 10)

В этом случае предикатом является функция **EVENP**, которая возвращает "истину", если её аргумент --- чётное число. Нотация #' является сокращением выражения "Получить функцию с данным именем". Без #' Lisp обратится к ''EVENP'' как к имени переменной и попытается получить ее значение, а не саму функцию.

Вы также можете передать в ''REMOVE-IF-NOT'' анонимную функцию. Например, если бы ''EVENP'' не существовало, вы могли бы так написать предыдущее выражение:

  CL-USER> (remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))
  (2 4 6 8 10)

В этом случае предикатом является анонимная функция
<code lisp>
(lambda (x) (= 0 (mod x 2)))
</code>
которая проверяет, равен ли нулю остаток от деления аргумента на 2 (другими словами, является ли аргумент чётным). Если вы хотите извлечь только нечётные числа, используя анонимную функцию, вы можете написать следующее:

  CL-USER> (remove-if-not #'(lambda (x) (= 1 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))
  (1 3 5 7 9)

Заметьте, что **lambda** не является именем функции --- это слово показывает, что вы определяете анонимную функцию((Слово ''lambda'' используется в Lisp из-за его изначальной связи с лямбда-исчислением, математическим формализмом, изобретенным для изучения математических функций.)). Если не считать имени, ''LAMBDA''-выражение выглядит очень похожим на ''DEFUN'': после слова ''lambda'' следует список параметров, за которым идёт тело функции.

Чтобы выбрать все альбомы Dixie Chicks из базы данных, используя ''REMOVE-IF-NOT'', вам нужна функция, возвращающая "истину", если поле в записи ''artist'' содержит значение "Dixie Chicks". Помните, мы выбрали //список свойств// в качестве представления записей базы данных, потому что функция ''GETF'' может извлекать из //списка свойств// именованные поля. Итак, полагая, что ''cd'' является именем переменной, хранящей одну запись базы данных, вы можете использовать выражение ''(getf cd :artist)'', чтобы извлечь имя исполнителя. Функция **EQUAL** посимвольно сравнивает переданные ей строковые параметры. Таким образом, ''(equal (getf cd :artist) "Dixie Chicks")'' проверит, хранит ли поле ''artist'', для текущей записи в переменной cd, значение "Dixie Chicks". Всё, что вам нужно --- упаковать это выражение в ''LAMBDA''-форму, чтобы создать анонимную функцию и передать ее ''REMOVE-IF-NOT''.

  CL-USER> (remove-if-not
    #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")) *db*)
  ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))


Предположим теперь, что вы хотите упаковать всё выражение в функцию, которая принимает имя исполнителя в качестве параметра. Вы можете записать это так:
<code lisp>
(defun select-by-artist (artist)
  (remove-if-not
   #'(lambda (cd) (equal (getf cd :artist) artist))
   *db*))
</code>

Заметьте, что анонимная функция, содержит код, который не будет выполнен, пока функция не вызвана в ''REMOVE-IF-NOT'', тем не менее она может ссылаться на переменную ''artist''. В этом случае анонимная функция не просто избавляет вас от необходимости писать обычную функцию, --- она позволяет вам написать функцию, которая берет часть своего значения - содержимое поля ''artist'' - из контекста в котором она вызывается.

Итак, мы покончили с функцией ''select-by-artist''. Однако выборка по исполнителю --- лишь одна разновидность запросов, которые вам захочется реализовать. Вы можете написать ещё несколько функций, таких, как ''select-by-title'', ''select-by-rating'', ''select-by-title-and-artist'', и так далее. Но все они будут идентичными, за исключением содержимого анонимной функции. Вместо этого вы можете создать более универсальную функцию ''select'', которая принимает функцию в качестве аргумента.
<code lisp>
(defun select (selector-fn)
  (remove-if-not selector-fn *db*))
</code>

А что случилось с ''#'''? Дело в том, что в этом случае вам не нужно, чтобы функция ''REMOVE-IF-NOT'' использовала функцию под названием ''selector-fn''. Вы хотите, чтобы она использовала анонимную функцию, переданную в качестве аргумента функции ''select'' в переменной ''selector-fn''. Однако, символ #' вернулся в вызов ''select'':

  CL-USER> (select #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")))
  ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))

Правда, это выглядит довольно грубо. К счастью, вы можете упаковать создание анонимной функции.
<code lisp>
(defun artist-selector (artist)
  #'(lambda (cd) (equal (getf cd :artist) artist)))
</code>

''artist-selector'' возвращает функцию, имеющую ссылку на переменную, которая перестанет существовать после выхода из ''artist-selector''((Техническое обозначение функции, ссылающейся на свободную переменную в своём контексте --- **замыкание**, потому что функция как бы "смыкается" над переменной. Я подробнее расскажу о замыканиях в главе 6.)). Функция выглядит странно, но она работает именно так, как нам нужно --- если вызвать ''artist-selector'' с аргументом "Dixie Chicks", мы получим анонимную функцию, которая ищет CD с полем '':artist'', содержащим "Dixie Chicks", и если вызвать её с аргументом "Lyle Lovett", то мы получим другую функцию, которая будет искать CD с полем '':artist'', содержащим "Lyle Lovett". Итак, мы можем переписать вызов ''select'' следующим образом:

  CL-USER> (select (artist-selector "Dixie Chicks"))
    ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
     (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))

Теперь нам понадобится больше функций, чтобы генерировать выражения для выбора. Но так как вы не хотите писать ''select-by-title'', ''select-by-rating'' и др., потому что они будут во многом схожими, вы не станете создавать множество почти идентичных генераторов выражений для выбора значений для каждого из полей. Почему бы не написать генератор функции-выражения для выбора общего назначения --- функцию, которая, в зависимости от передаваемых ей аргументов, будет генерировать выражение выбора для разных полей или, может быть, даже комбинации полей? Вы можете написать такую функцию, но сначала нам придётся пройти краткий курс для овладения средством, называемым //параметрами-ключами// (keyword parameters).

В функциях, что вы писали до этого, вы задавали простой список параметров, которые связывались с соответствующими аргументами в вызове функции. Например, следующая функция:
<code lisp>
(defun foo (a b c) (list a b c))
</code>
имеет три параметра: ''a'', ''b'' и ''c'', и должна быть вызвана с тремя аргументами. Но иногда возникает необходимость в вызове функции, которая может вызываться с переменным числом аргументов. Параметры-ключи --- один из способов это сделать. Версия ''foo'' с использованием параметров-ключей может выглядеть так:
<code lisp>
(defun foo (&key a b c) (list a b c))
</code>

Единственное отличие --- элемент **&key** в начале списка аргументов. Однако вызовы новой функции ''foo'' выглядят немного по-другому. Все нижеперечисленные варианты вызова ''foo'' допустимы, результат вызова помещён справа от %%==>%%.

  (foo :a 1 :b 2 :c 3)  ==> (1 2 3)
  (foo :c 3 :b 2 :a 1)  ==> (1 2 3)
  (foo :a 1 :c 3)       ==> (1 NIL 3)
  (foo)                 ==> (NIL NIL NIL)

Как показывают эти примеры, значения переменных ''a'', ''b'' и ''c'' привязаны к значениям, которые следуют за соответствующими ключевыми словами. И если какой-либо ключ в вызове отсутствует, соответствующая переменная устанавливается в ''NIL''. Я не буду уточнять, как именно задаются ключевые параметры и как они соотносятся с другими типами параметров, но вам важно знать одну деталь.

Обычно, когда функция вызывается без аргумента для конкретного параметра-ключа, параметр будет иметь значение ''NIL''. Но иногда нужно различать ''NIL'', который был явно передан в качестве аргумента к параметру-ключу, и ''NIL'', который задаётся по умолчанию. Чтобы сделать это, при задании параметра-ключа вы можете заменить обычное имя списком, состоящим из имени параметра, его значения по умолчанию и другого имени параметра, называемого параметром ''supplied-p''. Этот параметр ''supplied-p'' будет содержать значения "истина" или "ложь", в зависимости от того, действительно ли для данного параметра-ключа в данном вызове функции был передан аргумент. Вот версия новой функции ''foo'', которая использует эту возможность.
<code lisp>
(defun foo (&key a (b 20) (c 30 c-p)) (list a b c c-p))
</code>

Результаты тех же вызовов теперь выглядят иначе:


  (foo :a 1 :b 2 :c 3)  ==> (1 2 3 T)
  (foo :c 3 :b 2 :a 1)  ==> (1 2 3 T)
  (foo :a 1 :c 3)       ==> (1 20 3 T)
  (foo)                 ==> (NIL 20 30 NIL)

Основной генератор выражения выбора, FIXME который по причинам, которые, если вы знакомы с SQL, скоро станут очевидными, можно назвать **where**, является функцией, принимающей четыре параметра-ключа для соответствующих полей в наших записях CD и генерирующей выражение выбора, которое возвращает все записи о CD, совпадающие со значениями, задаваемым в ''where''. Например, можно будет написать такое выражение:
<code lisp>
(select (where :artist "Dixie Chicks"))
</code>
Или такое:
<code lisp>
(select (where :rating 10 :ripped nil))
</code>

Функция выглядит так:
<code lisp>
(defun where (&key title artist rating (ripped nil ripped-p))
  #'(lambda (cd)
    (and
      (if title    (equal (getf cd :title)  title)  t)
      (if artist   (equal (getf cd :artist) artist) t)
      (if rating   (equal (getf cd :rating) rating) t)
      (if ripped-p (equal (getf cd :ripped) ripped) t))))
</code>

Эта функция возвращает анонимную функцию, возвращающую логическое И для одного условия в каждом поле записей о CD. Каждое условие проверяет, задан ли подходящий аргумент, и если задан, то сравнивает его значение со значением соответствующего поля в записи о CD, или возвращает ''t'', обозначение истины в Lisp, если аргумент не был задан. Таким образом, выражение выбора возвратит ''t'' только для тех CD, описание которых совпало по значению с аргументами переданными ''where''((Заметьте, что в Lisp оператор ''if'', как и всё остальное, является выражением, возвращающим значение. Вообще, он больше напоминает тернарный оператор ''(?:)'' в Perl, Java и C, поскольку вполне допустимо такое выражение в этих языках:
<code c>
some_var = some_boolean ? value1 : value2;
</code>
А такое - нет:
<code c>
some_var = if (some_boolean) value1; else value2;
</code>
так как в этих языках ''if'' --- просто оператор, а не выражение.)). Заметьте, что, чтобы задать ключ-параметр ''ripped'', вам необходимо использовать список из трёх элементов, потому что вам нужно знать, действительно ли вызывающая функция передала ключ-параметр '':ripped nil'', означающее "Выбрать те CD, в поле ''ripped'' которых установлено значение ''nil''", либо опустила его, что означает "Мне всё равно, какое значение установлено в поле ''ripped''".






===== Обновление существующих записей — повторное использование where =====
Теперь, после того, как у вас есть достаточно универсальные функции ''select'' и ''where'', очень логичной представляется реализация следующей возможности, которая необходима каждой базе данных, --- возможности обновления отдельных записей. В SQL команда ''update'' используется для обновления набора записей, удовлетворяющих конкретному условию ''where''. Эта модель кажется хорошей, особенно когда у вас уже есть генератор условий ''where''. Фактически, функция ''update'' --- применение некоторых идей, которые вы уже видели: использование передаваемого выражения выбора для указания записей, подлежащих обновлению, и использование аргументов-ключей для задания нового значения. Новая вещь здесь --- использование функции **MAPCAR**, которая проходит по списку, в нашем случае это ''*db*'', и возвращает новый список, содержащий результаты вызова функции для каждого элемента исходного списка.
<code lisp>
(defun update (selector-fn &key title artist rating (ripped nil ripped-p))
  (setf *db*
        (mapcar
         #'(lambda (row)
             (when (funcall selector-fn row)
               (if title    (setf (getf row :title) title))
               (if artist   (setf (getf row :artist) artist))
               (if rating   (setf (getf row :rating) rating))
               (if ripped-p (setf (getf row :ripped) ripped)))
             row) *db*)))
</code>

Ещё одна новинка в этой функции((Автор ещё забыл упомянуть макрос ''WHEN''. Он будет подробно рассмотрен в 7-й главе. --- прим.ред.)) --- приложение ''SETF'' к сложной форме вида ''(getf row :title)''. Я расскажу о ''SETF'' подробнее в главе 6, но сейчас вам просто нужно знать, что это общий оператор присваивания, который может использоваться для присваивания друг другу различных "вещей", а не только переменных. (То, что ''SETF'' и ''GETF'' имеют настолько похожие имена --- просто совпадение. Между ними нет никакой особой взаимосвязи). Сейчас достаточно знать, что после выполнения ''(setf (getf row :title) title)'' у списка свойств, на который ссылается ''row'', значением переменной, следующей за именем свойства '':title'', будет title. С помощью функции ''update'', если вы решите, что действительно любите творчество Dixie Chicks, и что все их альбомы должны быть оценены в 11 баллов, можете выполнить следующую форму((Странно, что функция ''update'' здесь возвращает NIL, ведь последней операцией является ''SETF *db* value'', которая, в свою очередь, возвращает присвоенное значение. То есть после присваивания можно наблюдать изменения. (sbcl-1.03) //--- Прим. перев.//)):

  CL-USER> (update (where :artist "Dixie Chicks") :rating 11)
  NIL

Результат работы функции будет выглядеть так:

  CL-USER> (select (where :artist "Dixie Chicks"))
  ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 11 :RIPPED T)
   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 11 :RIPPED T))

Добавить функцию удаления строк из базы данных еще проще.
<code lisp>
(defun delete-rows (selector-fn)
  (setf *db* (remove-if selector-fn *db*)))
</code>

Функция **REMOVE-IF** является дополнением к ''REMOVE-IF-NOT'', она возвращает список всех элементов, удалив те из них, что удовлетворяют предикату. Так же, как и ''REMOVE-IF-NOT'', она, в действительности, не изменяет список, который был ей передан в качестве параметра, тем не менее, сохраняя результат обратно в ''*db*'', ''delete-rows''((Вы должны использовать имя ''delete-rows'' вместо более очевидного ''delete'', потому что в Common Lisp уже есть функция **DELETE**. Система пакетов Lisp предоставляет возможность разрешать такие конфликты имён, так что, если хотите, можете иметь в своей программе собственную функцию ''delete''. Но сейчас ещё рано рассказывать вам о пакетах.)) фактически изменяет содержимое базы данных((Если вы беспокоитесь о том, что в этом коде могут возникнуть утечки памяти, будьте уверены: Lisp был первым языком, в котором появилась сборка мусора (и, раз уж на то пошло, использование динамически выделяемой памяти). Память, используемая для старого значения *db*, будет автоматически возвращена системе, как только выяснится, что на неё больше ничто не ссылается.)).







===== Избавление от дублирующего кода и большой выигрыш =====
До сих пор весь код базы данных, обеспечивающий операции ''INSERT'', ''SELECT'', ''UPDATE'' и ''DELETE'', если не считать интерфейс командной строки для добавления новых записей и распечатки содержимого базы, укладывался в немногим более пятидесяти строк. Целиком((Мой друг однажды проводил собеседование с кандидатом на должность программиста и задал ему обычный вопрос, распространённый на таких собеседованиях: "Как вы понимаете, что функция (или метод) стала слишком велика?" "Ну... --- ответил кандидат. --- Я стараюсь делать так, чтобы любой метод был меньше, чем моя голова."
"Вы хотите сказать, что не можете удержать в голове всех деталей?" --- "Нет, я хочу сказать, что сажусь перед монитором, и код не должен быть больше, чем моя голова.")).

Всё еще существует некоторое раздражающее дублирование кода. И, оказывается, вы можете избавиться от этого дублирования, в то же время сделав код более гибким. Дублирование, о котором я говорю, находится в функции ''where''. Тело функции ''where'' --- набор условий для каждого поля, таких, как это:
<code lisp>
(if title (equal (getf cd :title) title) t)
</code>

Сейчас это не так плохо, но, как и во многих случаях дублирования кода, за это всегда приходится платить одну цену: если вы хотите изменить работу этого кода, вам нужно изменять множество копий. И если вы изменили поля в CD, вам придётся добавить или удалить условия для ''where''. ''update'' страдает точно таким же дублированием. Это, несомненно, плохо, так как весь смысл функции ''where'' заключается в динамической генерации куска кода, проверяющего нужные нам значения; почему она должна производить работу во время выполнения, каждый раз проверяя, было ли ей передано значение ''title''?

Представьте, что вы попытались оптимизировать этот код и обнаружили, что много времени тратится на проверку того, заданы ли значения ''title'' и оставшиеся ключ-параметры((Вряд ли проверка того, был ли ключ-параметр передан в функцию, приведёт к существенному падению производительности, так как проверка значения переменной на NIL --- очень "дешёвая" с точки зрения производительности операция. С другой стороны, эти функции, возвращаемые ''where'', оказываются как раз в середине внутреннего цикла вызовов ''select'', ''update'' и ''delete-rows'', так как вызываются для каждой записи в базе данных. В любом случае, для наглядности, пусть будет так.)). Если вы на самом деле хотите избавиться от этих проверок во время выполнения, вы можете просмотреть программу и найти все места, где вы вызываете ''where'', и посмотреть, какие аргументы вы передаёте. Затем вы можете заменить каждый вызов ''where'' анонимной функцией, выполняющей только необходимое вычисления. Например, если вы нашли такой кусок кода:
<code lisp>
(select (where :title "Give Us a Break" :ripped t))
</code>
вы можете заменить его на такой:
<code lisp>
(select
 #'(lambda (cd)
     (and (equal (getf cd :title) "Give Us a Break")
          (equal (getf cd :ripped) t))))
</code>

Заметьте, что анонимная функция отличается от той, что возвращает ''where''; мы не пытаемся сохранить вызов ''where'', а обеспечиваем большую производительность функции выбора. Эта анонимная функция имеет условия только для нужных нам полей, и она не производит дополнительной работы, в отличие от функции, которую может возвратить ''where''.

Вы можете представить себе, что значит пройтись по всему исходному тексту исправить все вызовы ''where'' таким образом. И вы можете представить, насколько это болезненно. Если бы этого было достаточно, и это было бы очень важно, вероятно, стоило бы написать некоторого рода препроцессор, который бы конвертировал вызовы ''where'' в то, что вы бы написали вручную.

Средство Lisp, позволяющее делать это очень просто, называется системой макросов. Подчеркиваю, что макрос в Common Lisp не имеет, в сущности, ничего общего (кроме имени) с текстовыми макросами из C и C++. В то время, как препроцессор C оперирует текстовой подстановкой и не знает ничего о стуктуре C и C++, в Lisp макрос, в сущности, является генератором кода, который автоматически запускается для вас компилятором((Макросы также выполняются интерпретатором, --- тем не менее, сущность макросов легче понять, когда думаешь о компилируемом коде. Как и обо всём остальном в этой главе, я расскажу об этом более подробно в следующих главах.)). Когда выражение на Lisp содержит вызов макроса, компилятор Lisp, вместо вычисления аргументов и передачи их в функцию, передает аргументы, не вычисляя их, в код макроса, который, в свою очередь, возвращает новое выражение на Lisp, которое затем вычисляется в месте исходного вызова макроса.

Я начну с простого и глупого примера и затем покажу, как вы можете заменить функцию ''where'' макросом ''where''. Перед тем, как я напишу этот макрос-пример, мне необходимо представить вам одну новую функцию: **REVERSE** принимает аргумент в виде списка и возвращает новый список, который является обратным к исходному. Таким образом, ''(reverse '(1 2 3))'' вернёт ''(3 2 1)''. Теперь попробуем создать макрос.
<code lisp>
(defmacro backwards (expr)
  (reverse expr))
</code>

Главное синтаксическое отличие между функцией и макросом заключается в том, что макрос определяется ключевым словом **DEFMACRO**, а не ''DEFUN''. После ключевого слова в определении макроса, подобно определению функции, следует имя, список параметров и тело с выражениями. Однако макросы действуют совершенно по-другому. Вы можете использовать макрос так:

  CL-USER> (backwards ("hello, world" t format))
  hello, world
  NIL

Как это работает? Когда REPL начинает вычислять выражение ''backwards'', он обнаруживает, что ''backwards'' --- имя макроса. Поэтому он не вычисляет выражение ''("hello, world" t format)'', что очень хорошо, так как это некорректная для Lisp структура. Далее он передаёт этот список коду ''backwards''. Код ''backwards'' передает список в функцию ''REVERSE'', которая возвращает список ''(format t "hello, world")''. Затем ''backwards'' передает это значение обратно REPL, который подставляет его на место исходного выражения.

Макрос ''backwards'', таким образом, определяет новый язык, во многом похожий на Lisp --- только задом наперёд --- который вы можете вставлять в свой код в любой момент, просто обернув обратное выражение на Lisp в вызов макроса ''backwards''. И в скомпилированной программе на Lisp этот новый язык покажет такую же производительность, как и обычный Lisp, потому что весь код в макросе --- код, сгенерированный в новом выражении --- выполняется во время компиляции. Другими словами, компилятор сгенерирует один и тот же код, независимо от того, напишете вы ''(backwards ("hello, world" t format))'' или ''(format t "hello, world")''.

Итак, как это поможет решить проблему дублирующегося кода в ''where''? Очень просто. Вы можете написать макрос, генерирующий совершенно такой же код, какой вы написали бы для каждого вызова ''where''. И снова, лучший подход --- это разрабатывать код снизу вверх. В оптимизированной вручную функции выбора ''where'' для каждого из заданных полей у вас было выражение в следующей форме:
<code lisp>
(equal (getf cd field) value)
</code>

Давайте напишем функцию, которая, получив имя поля и некоторое значение, возвращает такое выражение. Так как выражение --- это просто список, вы можете подумать, что возможно написать что-нибудь вроде:
<code lisp>
(defun make-comparison-expr (field value)    ; неправильно
  (list equal (list getf cd field) value))
</code>

Однако здесь имеется небольшой нюанс: как вы знаете, когда Lisp обнаруживает просто имя вроде ''field'' или ''value'', а не первый элемент списка, он полагает, что это имя переменной, и пытается получить ее значение. Это нормально для ''field'' и ''value''; это именно то, что нужно. Но он будет обращаться к ''equal'', ''getf'' и ''cd'' таким же образом, а это в нашем случае нежелательно. Вы, однако, знаете также, как не позволить Lisp пытаться вычислить структуру: поместить перед ней одиночную кавычку ('''''). Таким образом, если вы напишете функцию ''make-comparison-expr'' вот так, она сделает то, что вам нужно:
<code lisp>
(defun make-comparison-expr (field value)
  (list 'equal (list 'getf 'cd field) value))
</code>

Вы можете проверить её работу в REPL:

  CL-USER> (make-comparison-expr :rating 10)
  (EQUAL (GETF CD :RATING) 10)
  CL-USER> (make-comparison-expr :title "Give Us a Break")
  (EQUAL (GETF CD :TITLE) "Give Us a Break")

Но, оказывается, существует лучший способ сделать это. То, что вам действительно нужно, --- это иметь возможность написать выражение, которое в большинстве случаев не вычисляется, и затем каким-либо образом выбирать некоторые выражения, которые вы хотите вычислить. И, конечно же, такой механизм существует. Обратная кавычка (''`'') перед выражением запрещает его вычисление, точно так же, как и прямая одиночная кавычка.

  CL-USER> `(1 2 3)
  (1 2 3)
  CL-USER> '(1 2 3)
  (1 2 3)

Однако в выражении с обратной кавычкой любое подвыражение, перед которым стоит запятая, вычисляется. Обратите внимание на влияние запятой во втором выражении:

  `(1 2 (+ 1 2))  ==> (1 2 (+ 1 2))
  `(1 2 ,(+ 1 2)) ==> (1 2 3)

Используя обратную кавычку, вы можете переписать функцию ''make-comparison-expr'' следующим образом:
<code lisp>
(defun make-comparison-expr (field value)
  `(equal (getf cd ,field) ,value))
</code>

Теперь, если вы посмотрите на оптимизированную вручную функцию выбора, вы увидите, что тело функции состоит из одного оператора сравнения для каждой пары поле/значение, обернутое в выражение ''AND''. На мгновение предположим, что вам нужно расположить аргументы таким образом, чтобы передать их макросу ''where'' единым списком. Вам понадобится функция, которая принимает аргументы этого списка попарно и сохраняет результаты выполнения вызова ''make-comparison-expr'' для каждой пары. Чтобы реализовать эту функцию, вы можете воспользоваться мощным макросом **LOOP**.
<code lisp>
(defun make-comparisons-list (fields)
  (loop while fields
     collecting (make-comparison-expr (pop fields) (pop fields))))
</code>

Полное описание макроса ''LOOP'' отложим до 22 главы, а сейчас заметим, что выражение ''LOOP'' выполняет именно то, что требуется: оно циклично проходит по всем элементам в списке ''fields'', каждый раз возвращая по два элемента, передаёт их в ''make-comparison-expr'' и сохраняет возвращаемые результаты, чтобы их вернуть при выходе из цикла. Макрос POP выполняет операцию, обратную операции, выполняемой макросом ''PUSH'', который вы использовали для добавления записей в ''*db*''.

Теперь вам нужно просто обернуть список, возвращаемый функцией ''make-comparison-list'' в ''AND'' и анонимную функцию, которую вы можете реализовать прямо в макросе ''where''. Это просто: используйте обратную кавычку, чтобы создать шаблон, который будет заполнен значениями функции ''make-comparison-list''.
<code lisp>
(defmacro where (&rest clauses)
  `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
</code>

Этот макрос использует вариацию '','' (а именно, '',@'') перед вызовом ''make-comparison-list''. Сочетание '',@'' "вклеивает" значение следующего за ним выражения, которое должно возвращать список, во "внешний" список.

  `(and ,(list 1 2 3))  ==> (AND (1 2 3))
  `(and ,@(list 1 2 3)) ==> (AND 1 2 3)

Вы также можете использовать '',@'' для "вклейки" элементов в середину списка:

  `(and ,@(list 1 2 3) 4) ==> (AND 1 2 3 4)

Другая важная особенность макроса ''where'' --- использование ''&rest'' в списке аргументов. Так же, как и ''&key'', ''&rest'' изменяет способ разбора аргументов. Если в списке параметров обнаруживается ''&rest'', функция или макрос могут принимать произвольное число аргументов, которые собираются в единый список, становящийся значением переменной, имя которой следует за ''&rest''. Итак, если вы вызовите ''where'' так:
<code lisp>
(where :title "Give Us a Break" :ripped t)
</code>
переменная ''clauses'' будет содержать список:
<code lisp>
(:title "Give Us a Break" :ripped t)
</code>

Этот список передается функции ''make-comparisons-list'', которая возвращает список выражений сравнения. С помощью функции **MACROEXPAND-1** вы можете точно видеть, какой код будет сгенерирован ''where''. Если вы передадите в ''MACROEXPAND-1'' форму, являющуюся вызовом макроса, она вызовет макрос с заданными аргументами и вернёт его развёрнутый вид. Итак, вы можете проверить предыдущий вызов ''where'' следующим образом:

  CL-USER> (macroexpand-1 '(where :title "Give Us a Break" :ripped t))
  #'(LAMBDA (CD)
      (AND (EQUAL (GETF CD :TITLE) "Give Us a Break")
           (EQUAL (GETF CD :RIPPED) T)))
  T

Выглядит неплохо. Теперь попробуем испытать макрос в действии:

  CL-USER> (select (where :title "Give Us a Break" :ripped t))
  ((:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T))

Работает. И макрос ''where'' с его двумя функциями-помощниками оказался на одну строку короче, чем старая функция ''where''. И, что самое главное, ''where'' больше не привязана к конкретным полям наших записей о CD.

===== Об упаковке =====
Случилась интересная вещь. Вы избавились от дублирования и сделали код одновременно более производительным и универсальным. Так часто бывает, если правильно выбрать макрос. Это имеет смысл, потому что макрос --- это ещё один механизм создания абстракций --- абстракций на синтаксическом уровне, а абстракции --- это, по определению, более короткий путь для выражения подразумеваемых сущностей. Сейчас код мини-базы данных, который относится к CD и полям, его описывающим, находится только в функциях ''make-cd'', ''prompt-for-cd'' и ''add-cd''. Фактически, наш новый макрос будет работать с любой базой данных, основанной на списке свойств.

Тем не менее, эта база данных всё еще далека от завершения. Вероятно, вы думаете о добавлении множества возможностей, например, таких, как поддержка множества таблиц или более сложных запросов. В главе 27 мы создадим базу данных о записях MP3, которая будет содержать некоторые из этих возможностей.

Целью этой главы являлось быстрое введение в лишь малую часть возможностей Lisp и демонстрация того, как они используются для написания кода, чуть более интересного, чем ''"Hello, world"''. В следующей главе мы начнём более систематический обзор Lisp.