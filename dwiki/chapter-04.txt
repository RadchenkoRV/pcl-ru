====== 4. Синтаксис и семантика ======

После столь стремительного тура мы угомонимся на несколько глав, чтобы подробнее рассмотреть возможности, которые использовали до сих пор. Я начну с обзора базовых элементов синтаксиса и семантики Lisp, что, конечно же, означает, что я должен сначала ответить на неотложный вопрос...

===== Зачем столько скобок? =====

Синтаксис Lisp немного отличается от синтаксиса языков, произошедших от Algol. Две наиболее очевидные черты --- это обширное использование скобок и префиксная нотация. По непонятной причине, такой синтаксис отпугивает многих людей. Противники Lisp склонны описывать его синтаксис как "запутанный" и "раздражающий". Название "Lisp", по их словам, должно обозначать "Множество Раздражающих Ненужных Скобок" (Lots of Irritating Superfluous Parentheses). С другой стороны, люди, использующие Lisp, склонны рассматривать его синтаксис как одно из главных его достоинств. Как может быть то, что так не нравится одной группе, быть предметом восхищения другой?

Я не смогу исчерпывающе обосновать необходимость такого синтаксиса, до тех пор пока не рассказано подробней о макросах Lisp. Но я могу начать с интересной предыстории, которая намекает, что возможно стоит остаться непредвзятым: когда John McCarthy изобрел Lisp, он собирался реализовать его в более Algol-подобном синтаксисе, который он называл M-выражения. Однако он так не и сделал этого. Причину он объясняет в своей статье "История Lisp"((http://www-formal.stanford.edu/jmc/history/lisp/node3.html)).

> Проект по точному определению М-выражений и их компиляции или, хотя бы,
> трансляции их в S-выражения не был ни завершен, ни явно заброшен. Он
> просто был отложен на неопределенное будущее, а тем временем появилось новое
> поколение программистов, которые предпочитали S-выражения любой Fortran- или
> Algol-подобной нотации, которая только может быть выдумана.

Другими словами, люди, которые действительно использовали Lisp на протяжении последних 45 лет, //полюбили// синтаксис и нашли, что он делает язык более мощным. По прочтении последующих глав вы начнете понимать почему.






===== Разделение черного ящика =====

Перед тем, как мы рассмотрим специфику синтаксиса и семантики Lisp, будет полезно уделить внимание тому, как они определены и чем отличаются от множества других языков.

В большинстве языков программирования процессор языка (интерпретатор или компилятор) работает как черный ящик: вы помещаете последовательность символов, представляющих собой текст программы, в черный ящик и он (в зависимости от того, является ли он интерпретатором или компилятором) либо выполняет указанные инструкции, либо создает скомпилированную версию программы, которая выполняет инструкции после запуска.

Внутри черного ящика, конечно, процессоры языка обычно разделяются на подсистемы, каждая из которых ответственна за одну из частей задачи трансляции текста программы в последовательность инструкций или объектный код. Типичное разделение -- это разбиение работы процессора на три фазы, каждая из которых предоставляет данные следующей: лексический анализатор разделяет поток знаков на лексемы и передает их синтаксическому анализатору, который строит дерево, представляющее выражения программы в соответствии с грамматикой языка. Это дерево (называемое абстрактным синтаксическим деревом, AST) далее передается процедуре вычисления, которая либо напрямую интерпретирует его, либо компилирует его в какой-то другой язык; например в машинный код. Так как языковой процессор является черным ящиком, то структуры данных, используемые процессором, такие как лексемы или абстрактные синтаксические деревья, интересуют только конструкторов реализации языка.

В Common Lisp разбивка на фазы осуществлена немного иначе, с последствиями как для конструкторов реализации, так и для определения языка. Вместо одного черного ящика, который осуществляет переход от текста программы к ее поведению за один шаг, Common Lisp определяет два черных ящика, первый из которых транслирует текст в объекты Lisp, а другой реализует семантику языка в терминах этих объектов. Первый ящик называется процедурой чтения, а второй - процедурой вычисления((При реализации Lisp, как и при реализации любого языка, существует множество способов реализации процедуры вычисления, начиная от настоящих интерпретаторов, которые напрямую интерпретируют объекты, переданные процедуре вычисления, до компиляторов, транслирующих объекты в машинный код, который затем выполняется. Промежуточным решением являются реализации, в которых ввод компилируется в промежуточную форму, такую как байткоды для виртуальной машины, а затем происходит интерпретация этих байткодов. Большинство современных реализаций Common Lisp используют какую-либо форму компиляции, даже если вычисляют код во время выполнения)).

Каждый черный ящик определяет один уровень синтаксиса. Процедура чтения определяет, как строки знаков могут транслироваться в объекты, называемые s-выражениями((Иногда фраза s-выражение относится к текстовому представлению, а иногда -- к объектам, которые являются результатом чтения текстового представления. Обычно либо понятно из контекста, какое именно значение используется, либо разница не важна.)). Так как синтаксис s-выражений включает синтаксис для списков произвольных объектов, включая другие списки, s-выражения могут представлять произвольные древовидные выражения (//tree expressions//), очень похожие на абстрактные синтаксические деревья, генерируемые синтаксическими анализаторами не-Lisp языков.

В свою очередь, процедура вычисления определяет синтаксис форм Lisp, которые могут быть построены из s-выражений. Не все s-выражения являются допустимыми формами Lisp также как и не все последовательности знаков являются допустимыми s-выражениями. Например, и ''(foo 1 2)'', и ''("foo" 1 2)'' являются s-выражениями, но только первое может быть формой Lisp, так как список, который начинается со строки, не является формой Lisp.

Это разделение черного ящика имеет несколько следствий. Одно из них состоит в том, что вы можете использовать s-выражения, как вы видели в главе 3, в качестве внешнего формата для данных, не являющихся исходным кодом, используя **READ** для их чтения и **PRINT** для их записи((Не все объекты Lisp могут быть записаны таким образом, чтобы их можно было снова прочитать. Но все, что вы можете прочитать с помощью **READ**, может быть записано с помощью **PRINT** так, чтобы это можно было впоследствии прочитать)). Другое следствие состоит в том, что так как семантика языка определена в терминах деревьев объектов, а не в терминах строк знаков, то генерировать код внутри языка становится легче, чем это можно было бы сделать, если бы код генерировался как текст. Генерирование кода полностью с нуля не намного легче: и построение списков, и построения строк являются примерно одинаковыми по сложности работами. Однако реальный выигрыш в том, что вы можете генерировать код, манипулируя существующими данными. Это является базой для макросов Lisp, которые я опишу гораздо подробнее в будущих главах. Сейчас я сфокусируюсь на двух уровнях синтаксиса, определенных Common Lisp: это синтаксис s-выражений, понимаемый процедурой чтения, и синтаксис форм Lisp, понимаемый процедурой вычисления.





===== S-выражения =====

Базовыми элементами s-выражения являются списки и атомы. Списки ограничиваются скобками и могут содержать любое число разделенных пробелами элементов. Все, что не список, является атомом((Пустой список, ''()'', который также может быть записан как **NIL**, является одновременно и списком и атомом.)). Элементами списков в свою очередь также являются s-выражения (другими словами, атомы или вложенные списки). Комментарии (которые, строго говоря, не являются s-выражениями) начинаются с точки с запятой, распространяются до конца строки, и трактуются как пробел.

И это почти все. Так как списки синтаксически просты, то те оставшиеся синтаксические правила, которые вам необходимо знать, касаются только различных типов атомов. В этой секции я опишу правила для большинства часто используемых типов атомов: чисел, строк и имен. После этого, я расскажу как s-выражения, составленные из этих элементов, могут быть вычислены как формы Lisp.

С числами все довольно очевидно: любая последовательность цифр (возможно,  начинающаяся со знака (+ или -), содержащая десятичную точку или знак деления, и, возможно, заканчивающаяся меткой показателя степени) трактуется как число. Например:

  123       ; целое число "сто двадцать три"
  3/7       ; отношение "три седьмых"
  1.0       ; число с плавающей точкой "один" с точностью, заданной по умолчанию
  1.0e0     ; другой способ записать то же самое число с плавающей точкой
  1.0d0     ; число с плавающей точкой "один" двойной точности
  1.0e-4    ; эквивалент с плавающей точкой числа "одна десятитысячная"
  +42       ; целое число "сорок два"
  -42       ; целое отрицательное число "минус сорок два"
  -1/4      ; отношение "минус одна четвертая"
  -2/8      ; другой способ записать то же отношение
  246/2     ; другой способ записать целое "сто двадцать три"

Эти различные формы представляют различные типы чисел: целые, рациональные, числа с плавающей точкой. Lisp также поддерживает комплексные числа, которые имеют свою собственную нотацию, и которые мы рассмотрим в главе 10.

Как показывают некоторые из этих примеров, вы можете задать одно и то же число множеством различных способов. Но независимо от того, как вы запишите их, все рациональные (целые и отношения) внутри Lisp представляются в "упрощенной" форме. Другими словами, объекты, которые представляют числа -2/8 и 246/2, не отличаются от объектов, которые представляют числа -1/4 и 123. Таким же образом, 1.0 и 1.0e0 -- просто два разных способа записать одно число. С другой стороны, 1.0, 1.0d0 и 1 могут представлять различные объекты, так как различные представления чисел с плавающей точкой и целых чисел являются различными типами. Мы рассмотрим детали характеристик различных типов чисел в главе 10.

Строковые литералы, как вы видели в предыдущей главе, заключаются в двойные кавычки. Внутри строки обратный слеш (\) экранирует следующий знак, что вызывает включение этого знака в строку "как есть". Только два знака должны быть экранированы в строке: двойная кавычка и сам обратный слеш. Все остальные знаки могут быть включены в строковый литерал без экранирования, не обращая внимания на их значение вне строки. Несколько примеров строковых литералов:

  "foo"     ; строка, содержащая знаки 'f', 'o' и 'o'.
  "fo\o"    ; такая же строка.
  "fo\\o"   ; строка, содержащая знаки 'f', 'o', '\' и 'o'.
  "fo\"o"   ; строка, содержащая знаки 'f', 'o', '"' и 'o'.

Имена, использующиеся в программах на Lisp, такие как **FORMAT**, ''hello-world'' и ''*db*'' представляются объектами, называющимися //символами//. Процедура чтения ничего не знает о том, как данное имя будет использоваться -- является ли оно именем переменной, функции или чем-то еще. Она просто читает последовательность знаков и создает объект, представляющий имя((Фактически, как вы увидите далее, имена по сути не связаны ни с какими вещами. Вы можете использовать одинаковое имя, в зависимости от контекста, для ссылки и на переменную, и на функцию, не говоря уже о некоторых других возможностях.)). Почти любой знак может входить в имя. Однако, это не может быть пробельный знак, так как пробелом разделяются элементы списка. Цифры могут входить в имена, если имя целиком не сможет интерпретироваться как число. Схожим образом, имена могут содержать точки, но процедура чтения не может прочитать имя, состоящее только из точек. Существует десять знаков, которые не могут входить в имена, так как предназначены для других синтаксических целей: открывающая и закрывающая скобки, двойные и одинарные кавычки, обратный апостроф, запятая, двоеточие, точка с запятой, обратный слеш и вертикальная черта. Но даже эти знаки могут входить в имена, если их экранировать обратным слешем или окружить часть имени, содержащую знаки, которые нужно экранировать, с помощью вертикальных линий.

Две важные характерные черты того, каким образом процедура чтения переводит имена в символьные объекты, касаются того, как она трактует регистр букв в именах и как она обеспечивает то, чтобы одинаковые имена всегда читались как одинаковые символы. Во время чтения имен процедура чтения конвертирует все неэкранированные знаки в именах в их эквивалент в верхнем регистре. Таким образом, процедура чтения прочитает ''foo'', ''Foo'' и ''FOO'' как одинаковый символ: ''FOO''. Однако, ''\f\o\o'' и ''|foo|'' оба будут прочитаны как foo, что будет отличным от символа FOO объектом. Это как раз и является причиной, почему при определении функции в REPL, он печатает имя функции, преобразованное к верхнему регистру. Сейчас стандартным стилем является написание кода в нижнем регистре, позволяя процедуре чтения преобразовывать имена к верхнему((На самом деле, поведение процедуры чтения по конвертации регистра знаков может быть настроено, но понимание того, что и где изменять, требует гораздо более глубокого обсуждения об отношениях между именами, символами и другими элементами программы, чем я пока готов вам дать)).

Чтобы быть уверенным в том, что одно и то же текстовое имя всегда читается как один и тот же символ, процедура чтения хранит все символы -- после того, как она прочитала имя и преобразовала его к верхнему регистру, процедура чтения ищет в таблице, называемой //пакетом// (//package//), символ с таким же именем. Если она не может найти такой, то она создает новый символ и добавляет его к таблице. Иначе она возвращает символ, уже хранящийся в таблице. Таким образом, где бы одно и то же имя не появлялось в любых s-выражениях, оно будет представлено одним и тем же объектом((Более детально отношения между символами и пакетами я опишу в главе 21)).

Так как имена в Lisp могут содержать намного большее множество знаков, чем в языках, произошедших от Algol, в Lisp существуют определенные соглашения по именованию, такие как использование дефисов в именах наподобие ''hello-world''. Другое важное соглашение состоит в том, что глобальным переменным дают имена, начинающиеся и заканчивающиеся знаком *. Подобным образом, константам дают имена, начинающиеся и заканчивающиеся знаком +. Также некоторые программисты называют очень низкоуровневые функции именами, начинающимися с % или даже %%. Имена, определенные в стандарте языка, используют только алфавитные знаки (A-Z), а также *, +, -, /, 1, 2, <, =, >, &.

Синтаксис для списков, чисел, строк и символов описывает большую часть Lisp программ. Другие правила описывают нотацию для векторных литералов, отдельных знаков, массивов, которые я опишу в главах 10 и 11, когда мы будем говорить об этих типах данных. Сейчас главным является понимание того, как комбинируются числа, строки и символы с разделенными скобками списками для построения s-выражений, представляющих произвольные деревья объектов. Несколько простых примеров:

  x             ; символ X
  ()            ; пустой список
  (1 2 3)       ; список из трех элементов
  ("foo" "bar") ; список из двух строк
  (x y z)       ; список из трех символов
  (x 1 "foo")   ; список из символа, числа и строки
  (+ (* 2 3) 4) ; список из символа, списка и числа

Еще одним чуть более сложным примером является четырехэлементный список, содержащий два символа, пустой список и другой список, в свою очередь содержащий два символа и строку:

<code="lisp">
  (defun hello-world ()
    (format t "hello, world"))
</code>





===== S-выражения как формы Lisp =====

После того, как процедура чтения преобразовывает текст в s-выражения, эти s-выражения могут быть вычислены как код Lisp. Точнее некоторые из них могут -- не каждое s-выражение, которое процедура чтения может прочитать, обязательно может быть вычислено как код Lisp. Правила вычислений Common Lisp определяют второй уровень синтаксиса, который определяет, какие s-выражения могут трактоваться как формы Lisp((Конечно в Lisp существуют и другие уровни проверки корректности, как и в других языках. Например, s-выражение, являющееся результатом чтения ''(foo 1 2)'' синтаксически правильно, но может быть вычислено только если foo является именем функции или макроса)). Синтаксические правила на этом уровне очень просты. Любой атом (не список или пустой список) является допустимой формой Lisp, а также любой список, который содержит символ в качестве своего первого элемента, также является допустимой формой Lisp((Другой, редко используемый тип форм Lisp -- это список, первый элемент которого является лямбда-формой. Я обсужу этот тип форм в главе 5)).

Конечно, интересным является не синтаксис форм Lisp, а то, как эти формы вычисляются. Для целей дальнейшего обсуждения вам достаточно думать о процедуре вычисления как о функции, которая получает в качестве аргумента синтаксически правильную форму Lisp и возвращает значение, которое мы можем назвать //значением// (//value//) формы. Конечно, когда процедура вычисления является компилятором, это является небольшим упрощением -- в этом случае процедура вычисления получает выражение и генерирует код, который, будучи запущенным, вычислит соответствующее значение. Но это упрощение позволит мне описать семантику Common Lisp в терминах того, как различные типы форм Lisp вычисляются с помощью этой воображаемой функции.

Простейшие формы Lisp, атомы, могут быть разделены на две категории: символы и все остальное. Символ, вычисляемый как форма, трактуется как имя переменной и вычисляется в ее текущее значение((Существует одна иная возможность -- возможно определить //символьный// макрос (//symbol macros//), который вычисляется немного по другому. Мы не должны беспокоиться об этом)). Я обсужу в главе 6 как переменные получают свои значения впервые. Также следует заметить, что некоторые "переменные" являются старым программистским оксюмороном: "константными переменными". Например, символ **PI** именует константную переменную, чье значение -- число с плавающей точкой, являющееся наиболее близкой аппроксимацией математической константы π.

Все остальные атомы (числа и строки) являются типом объектов, который вы уже рассмотрели -- это //самовычисляемые объекты// (//self-evaluating objects//). Это означает, что когда выражение передается в воображаемую функцию вычисления, оно просто возвращается. Вы видели примеры самовычисляемости объектов в главе 2, когда набирали 10 и "hello, world" в REPL.

Символы также могут быть самовычисляемыми в том смысле, что переменной, которую именует такой символ, может быть присвоено значение самого этого символа. Две важные константы определены таким образом: **T** и **NIL**, стандартные истинное и ложное значения. Я обсужу их роль как логических выражений в секции "Правда, ложь и равенство".

Еще один класс самовычисляемых символов -- это //символы-ключи// (//keyword symbols//) -- символы, чьи имена начинаются с :. Когда процедура чтения обрабатывает такое имя, она автоматически определяет константную переменную с таким именем и таким символом в качестве значения.

Всё становится гораздо интереснее при рассмотрении того, как вычисляются списки. Все допустимые формы списков начинаются с символа, но существуют три разновидности форм списков, которые вычисляются тремя различными способами. Для определения того, какую разновидность формы представляет из себя данный список, процедура вычисления должна определить чем является первый символ списка: именем функции, макросом или специальным оператором. Если символ еще не был определен (такое может быть в случае, если вы компилируете код, который содержит ссылки на функции, которые будут определены позднее) -- предполагается, что он является именем функции((В Common Lisp символ может именовать как оператор (функцию, макрос или специальную форму), так и переменную. Это одно из главных отличий между Common Lisp и Scheme. Эта разница иногда описывается как то, что Common Lisp является Lisp-2, а Scheme -- Lisp-1. Lisp-2 имеет два пространства имен, одно для операторов и одно для переменных, а Lisp-1 использует единое пространство имен. Оба подхода имеют свои преимущества, и их поборники ведут нескончаемые споры, что же все-таки лучше)). Я буду ссылаться на эти три разновидности форм как на //формы вызова функции// (//function call forms//), //формы макросов// (//macro forms//) и //специальные формы// (//special forms//).


===== Вызовы функций =====

Правило вычисления для форм вызова функции просто: вычисление элементов списка, начиная со второго, как форм Lisp и передача результатов в функцию, именованную первым элементом. Это правило явно добавляет несколько дополнительных синтаксических ограничений на форму вызова функции: все элементы списка после первого должны также быть правильными формами Lisp. Другими словами, базовый синтаксис формы вызова функции следующий (каждый аргумент также является формой Lisp):

  (function-name argument*)

Таким образом, следующее выражение вычисляется путем первоначального вычисления 1, затем 2, а затем передачи результатов вычислений в функцию +, которая возвращает 3:

<code="lisp">
  (+ 1 2)
</code>

Более сложное выражение, такое как следующее, вычисляется схожим образом за исключением того, что вычисление аргументов (+ 1 2) и (- 3 4) влечет за собой вычисление аргументов этих форм и применение соответствующих функций к ним:

<code="lisp">
  (* (+ 1 2) (- 3 4))
</code>

В итоге, значения 3 и -1 передаются в функцию *, которая возвращает -3.

Как показывают эти примеры, функции используются для многих вещей, которые требуют специального синтаксиса в других языках. Это помогает сохранять синтаксис Lisp регулярным.




===== Специальные операторы =====

Нужно сказать, что не все операции могут быть определены как функции. Так как все аргументы функции вычисляются перед ее вызовом, не существует возможности написать функцию, которая ведет себя как оператор **IF**, который вы использовали в главе 3. Для того, чтобы увидеть почему, рассмотрим такую форму:

<code="lisp">
  (if x (format t "yes") (format t "no"))
</code>

Если IF является функцией, процедура вычисления будет вычислять аргументы выражения слева направо. Символ x будет вычислен как переменная, возвращающая свое значение; затем как вызов функции будет вычислена ''(format t "yes")'', возвращающая **NIL** после печати "yes" на стандартный вывод; и затем будет вычислена (format t "no"), печатающая "no" и возвращающая **NIL**. Только после того, как эти три выражения будут вычислены, их результаты будут переданы в **IF**, слишком поздно для того, чтобы проконтролировать, какое из двух выражений **FORMAT** будет вычислено.

Для решения этой проблемы Common Lisp определяет небольшое количество так называемых специальных операторов (и один из них **IF**), которые делают те вещи, которые функции сделать не могут. Всего их 25, но только малая их часть напрямую используется в ежедневном программировании((Остальные предоставляют полезные, но в некотором роде эзотерические возможности. Я обсужу их, когда эти возможности нам понадобятся)).

Если первый элемент списка является символом, именующим специальный оператор, остальная часть выражения вычисляется в соответствии с правилом для этого оператора.

Правило для **IF** очень просто: вычисление первого выражения. Если оно вычисляется не в **NIL**, то вычисляется следующее выражение и возвращается его результат. Иначе возвращается значение вычисления третьего выражения или **NIL**, если третье выражение не задано. Другими словами, базовая форма выражения **IF** следующая:

<code="lisp">
  (if test-form then-form [ else-form ])
</code>

''test-form'' вычисляется всегда, а затем только одна из ''then-form'' и ''else-form''.

Еще более простой специальный оператор - это **QUOTE**, который получает одно выражение как аргумент и просто возвращает его не вычисляя. Например, следующая форма вычисляется в список ''(+ 1 2)'', а не в значение 3:

<code="lisp">
  (quote (+ 1 2))
</code>

Этот список не отличается ни от какого другого, вы можете манипулировать им также, как и любым другим, который вы можете создать с помощью функции **LIST**((Хорошо, одно отличие существует -- объекты-литералы, такие как закавыченые списки, литералы строк, массивов и векторов (синтаксис которых мы рассмотрим позднее), не должны модифицироваться. Поэтому, любые списки, которыми вы собираетесь манипулировать, вы должны создавать с помощью функции **LIST**.))

**QUOTE** используется достаточно часто, поэтому для него в процедуру чтения был встроен специальный синтаксис. Вместо написания такого:

<code="lisp">
  (quote (+ 1 2))
</code>

вы можете написать это:

<code="lisp">
  '(+ 1 2)
</code>

Этот синтаксис является небольшим расширением синтаксиса s-выражений, понимаемым процедурой чтения. С этой точки зрения для процедуры вычисления оба этих выражения выглядят одинаково: список, чей первый элемент является символом **QUOTE**, а второй элемент -- список ''(+ 1 2)''((Этот синтаксис является примером макроса процедуры чтения. Эти макросы используются для модификации синтаксиса процедуры чтения, который используется для трансляции текста в объекты Lisp. Фактически возможно определить собственный макрос процедуры чтения, но это редко используемая возможность языка. Когда большинство лисперов говорят об "расширении синтаксиса" языка, они говорят об обычных макросах, которые я скоро обсужу)).

В общем, специальные операторы реализуют возможности языка, которые требуют специальной обработки процедурой вычисления. Например, некоторые специальные операторы манипулируют окружением, в котором вычисляются другие формы. Один из них, который я обсужу детально в главе 6, - **LET**, который используется для создания новой //привязки переменной// (//variable binding//). Следующая форма вычисляется в 10, так как второй x вычисляется в окружении, где он именует переменную, связанную оператором **LET** со значением 10:

<code="lisp">
  (let ((x 10)) x)
</code>



===== Макросы =====

В то время как специальные операторы расширяют синтаксис Common Lisp, выходя за пределы того, что может быть выражено простыми вызовами функций, множество специальных операторов ограничено стандартом языка. С другой стороны, макросы дают пользователям языка способ расширения его синтаксиса. Как вы увидели в главе 3, макрос -- это функция, которая получает в качестве аргументов s-выражения и возвращает форму Lisp, которая затем вычисляется на месте формы макроса. Вычисление формы макроса происходит в две фазы: сначала элементы формы макроса передаются, не вычисляясь, в функцию макроса, а затем форма, возвращенная функцией макроса (называемая ее //раскрытием// (//expansion//)), вычисляется в соответствии с обычными правилами вычисления.

Очень важно понимать обе фазы вычисления форм макросов. Очень легко запутаться когда вы печатаете выражения в REPL, так как эти две фазы происходят одна за одной и значение второй фазы немедленно возвращается. Но, когда код Lisp компилируется, эти две фазы выполняются в разное время, и очень важно понимать, что и когда происходит. Например, когда вы компилируете весь файл с исходным кодом с помощью функции **COMPILE-FILE**, все формы макросов в файле рекурсивно раскрываются, пока код не станет содержать ничего кроме форм вызова функций и специальных форм. Этот не содержащий макросов код затем компилируется в файл FASL, который функция **LOAD** знает как загрузить. Скомпилированный код, однако, не выполняется пока файл не будет загружен. Так как макросы генерируют свое расширение во время компиляции, они могут проделывать довольно большой объем работы, генерируя свои раскрытия, без платы за это во время загрузки файла или при вызове функций, определенных в этом файле.

Так как процедура вычисления не вычисляет элементы формы макроса перед передачей их в функцию макроса, они не обязательно должны быть правильными формами Lisp. Каждый макрос назначает смысл s-выражениям, используемым в //форме// этого макроса (macro form), посредством того, как он использует эти s-выражения для генерации своего расширения. Другими словами, каждый макрос определяет свой собственный локальный синтаксис. Например, макрос переворачивания списка задом наперед из главы 3 определяет синтаксис, в котором выражение является допустимой перевернутой формой если ее список, будучи перевернутым, является допустимой формой Lisp.

Я расскажу больше о макросах в этой книге. А сейчас вам важно понимать, что макросы, несмотря на то, что синтаксически похожи на вызовы функции, служат иной цели, предоставляя добавочный уровень к компилятору((Люди, не имеющие опыта использования макросов Lisp или, хуже того, испорченные препроцессором C, часто нервничают, когда понимают, что вызовы макросов выглядят также как обычные вызовы функций. Но на практике это не является проблемой по нескольким причинам. Одной из них является то, что формы макросов обычно форматируются не так, как вызовы функций. Например, вы пишете так:
<code="lisp">(dolist (x foo)
  (print x))</code>
а не так
<code="lisp">(dolist (x foo) (print x))</code>
или 
<code="lisp">(dolist (x foo)
       (print x))</code>
как в случае, если бы **DOLIST** была функцией. Хорошая Lisp-среда автоматически форматирует вызовы макросов, в том числе макросы, определенные пользователем.

И даже если форма **DOLIST** была записана в одной строке, есть несколько вещей, указывающих на то, что это макрос. Одной из них является то, что выражение (''x'' ''foo'') имеет смысл только если ''x'' является именем функции или макроса. Если учитывать то, что до этого ''x'' использовалась как переменная, то становится очевидным, что **DOLIST** -- это макрос, который связывает переменную ''x'' с какими-то значениями. Соглашение по именованию также помогает -- конструкции циклов, являющиеся макросами, часто называют именами, начинающимися с //do//.)).




===== Истина, Ложь и Равенство =====

Оставшейся частью базовых знаний, которые вам необходимо получить, являются понятия истины, лжи и равенства объектов в Common Lisp. Понятия истины и лжи очень просты: символ **NIL** является единственным ложным значением, а все остальное является истиной. Символ **T** является каноническим истинным значением и может быть использован когда вам нужно вернуть не-**NIL** значение, но само значение не важно. Единственной хитростью является то, что **NIL** также является единственным объектом, который одновременно является и атомом и списком: вдобавок к представлению ложного значения он также используется для представления пустого списка((Использование пустого списка, как ложного значения, является отражением наследия Lisp как языка обработки списков, аналогично использованию целочисленного 0, в качестве ложного значения в С, что является отражением С как языка, предназначенного в том числе для манипуляций на уровне битов. Не все Lisp'ы оперируют булевыми значениями таким образом. Еще одним из многочисленных отличий, из-за которого хороший флейм Common Lisp vs Scheme может не утихать целыми днями, является наличие в Scheme отдельного ложного значения ''#f'', что не является тем же значением, что ''nil'' или пустой список, которые также отличны друг от друга)). Эта равнозначность **NIL** и пустого списка встроена в процедуру чтения: если процедура чтения видит ''()'', она считывает это как символ **NIL**. Обе записи полностью взаимозаменяемые. И так как **NIL**, как я уже упоминал раньше, является именем константной переменной, значением которой является символ **NIL**, то выражения ''nil'', ''()'', '' 'nil'' и '' '()'' вычисляются в одинаковый объект: unquoted формы вычисляются как ссылка на константную переменную, значение которой -- символ **NIL**, а quoted формы, при помощи оператора **QUOTE**, вычисляются в символ **NIL** напрямую. По этим же причинам, и ''t'' и '' 't'' будут вычислены в одинаковый объект: символ **T**.

Использование фраз, таких как "то же самое", конечно рождает вопрос о том, что  для двух значений значит "то же самое". Как вы увидите в следующих главах, Common Lisp предоставляет ряд типо-зависимых предикатов равенства: ''='' используется для сравнения чисел; ''CHAR='' для сравнения знаков и т.д. В этой секции мы рассмотрим четыре "общих" ("generic") предиката равенства -- функции, которым могут быть переданы два Lisp-объекта, и которые возвратят истину, если эти объекты эквивалентны, и ложь в противном случае. Вот они в порядке ослабления понятия "различности": **EQ**, **EQL**, **EQUAL**, и **EQUALP**.

**EQ** проверяет "идентичность объектов": она возвращает истинное значение если два объекта идентичны. К сожалению, понятие идентичности таких объектов, как числа и знаки, зависит от того, как эти типы данных реализованы в конкретной реализации Lisp. Таким образом, **EQ**  может считать два числа или два знака с одинаковым значением, как эквивалентными, так и нет. Стандарт языка оставляет реализациям достаточную свободу действий в этом вопросе, что приводит к тому, что выражение ''(eq 3 3)'' может вполне законно вычисляться как в истинное, так и в ложное значение. Таким же образом ''(eq x x)'' может вычисляться как в истинное, так и в ложное значение в различных реализациях если значением x является число или знак.

Поэтому вы никогда не должны использовать **EQ** для сравнения значений, которые могут оказаться числами или знаками. Может показаться, что она вполне предсказуемо работает для некоторых значений в конкретной реализации, но вы не можете гарантировать, что она будет работать таким же образом если вы смените реализацию. К тому же смена реализации может означать просто обновление вашей реализации до новой версии: если конструкторы вашей реализации изменили внутреннее представление чисел или знаков, то поведение **EQ** вполне могло измениться.

Поэтому, Common Lisp определяет **EQL**, работающую аналогично **EQ**, за исключением того, что она также гарантирует рассмотрение эквивалентными двух объектов одного класса, представляющих одинаковое числовое или знаковое (character) значение. Поэтому ''(eql 1 1)'' гарантировано будет истиной. А ''(eql 1 1.0)'' гарантировано будет ложью, так как целое значение 1 и значение с плавающей точкой 1.0 являются представителями различных классов.

Существуют два лагеря по отношению к вопросу где использовать **EQ** и где использовать **EQL**: сторонники "когда возможно всегда используйте **EQ**" убеждают вас использовать **EQ**, когда вы уверены, что не будете сравнивать числа или знаки так как:
a) это способ указать, что вы не собираетесь сравнивать числа и знаки;
b) это будет немного эффективней, так как **EQ** не нужно проверять, являются ли ее аргументы числами или знаками.

Сторонники "всегда используйте **EQL**" советуют вам никогда не использовать **EQ**, так как
(а) потенциальный выигрыш в ясности теряется, так как каждый раз, когда кто-либо будет читать ваш код (включая вас) и увидит **EQ**, он должен будет остановиться и проверить, корректно ли эта функция используется (другими словами, проверить, что она никогда не вызывается для сравнения цифр или знаков) и
(b) различие в эффективности между **EQ** и **EQL** очень мало по сравнению с производительностью в действительно узких местах.

Код в этой книге написан в стиле "всегда используйте **EQL**"((Даже стандарт языка немного неоднозначен, **EQ** или **EQL** отдать предпочтение. Тождество объектов определяется с помощью **EQ**, но стандарт определяет фразу "такой же", говоря об объектах, имея ввиду **EQL**, если другой предикат явно не упомянут. Поэтому, если вы хотите быть 100% технически корректны, вы можете говорить, что ''(- 3 2)'' и ''(- 4 3)'' вычисляются в "такой же" объект, но не то, что они вычисляюся в "идентичные" объекты. Это, по общему признанию, вопрос из разряда "сколько ангелов разместится на острие булавки")).

Другие два предиката равенства **EQUAL** и **EQUALP** являются общими в том смысле, что они могут оперировать всеми типами объектов, но они не настолько фундаментальные, как **EQ**  или **EQL**. Каждый из них определяет несколько более слабое понятие "различности", чем **EQL**, позволяя другим объектам считаться эквивалентным. Нет ничего особенного в тех конкретных понятиях эквивалентности, что реализуют эти функции, за исключением того, что они оказались полезными Lisp-программистам прошлого. Если эти предикаты не подходят вам, вы всегда можете определить свой собственный предикат для сравнения объектов других типов нужным вам способом.

**EQUAL** ослабляет понятие "различности" между **EQL**, считая списки эквивалентными, если они рекурсивно, согласно тому же **EQUAL**, имеют одинаковую структуру и содержимое. **EQUAL** также считает строки эквивалентными, если они содержат одинаковые знаки. **EQUAL** также ослабляет понятие "различности" по сравнению с **EQL** для битовых векторов (bit vectors) и путей -- двух типах, о которых я расскажу в следующих главах. Для всех остальных типов он аналогичен **EQL**.

**EQUALP** аналогична **EQUAL** за исключением еще большего ослабления понятия "различности". **EQUALP** считает две строки эквивалентными, если они имеют одинаковые знаки, игнорируя разницу в регистре. Два знака также считаются эквивалентными, если они отличается только регистром. Числа эквивалентны по **EQUALP**, если они представляют одинаковое математическое значение. Например, ''(equalp 1 1.0)'' вернет истину. Списки, элементы которых попарно эквивалентны по **EQUALP**, считаются эквивалентными; подобным же образом массивы с элементами, эквивалентными по **EQUALP**, также считаются эквивалентными. Как и в случае с **EQUAL**, существует несколько других типов данных, которые я пока не рассмотрел, для которых **EQUALP** может рассмотреть два объекта эквивалентными, в то время как **EQL** и **EQUAL** будут считать их различными. Для всех остальных типов данных **EQUALP** аналогична **EQL**.

===== Форматирование кода Lisp =====

Хотя форматирование кода, строго говоря, не имеет ни синтаксического, ни семантического значения, хорошее форматирование важно для легкого чтения и написания кода. Ключевым моментов в форматировании кода Lisp является правильная расстановка отступов. Отступы должны отражать структуру кода так, чтобы вам не пришлось считать скобки для его понимания. Вообще, каждый новый уровень вложенности должен иметь больший отступ, а если нужен перенос строки, то элементы следующей строки имеют тот же уровень вложенности, что и предыдущей. Таким образом, вызов функции, который должен быть разбит на несколько строк может быть записан следующим образом:

<code="lisp">
  (some-function arg-with-a-long-name
                 another-arg-with-an-even-longer-name)
</code>

Расстановка отступов в макросах и специальных формах, которые реализуют структуры контроля, обычно немного отличается: элементы "тела" отступаются на два пробела относительно открывающей скобки формы. Таким образом:

<code="lisp">
  (defun print-list (list)
    (dolist (i list)
      (format t "item: ~a~%" i)))
</code>

Однако, вам не нужно сильно беспокоиться на счет этих правил, так как хорошая среда Lisp, такая как SLIME, возьмет эту заботу на себя. Фактически, одним из преимуществ регулярного синтаксиса Lisp является то, что программному обеспечению, такому как текстовые редакторы, очень легко расставлять отступы. Так как расстановка отступов нужна для отражения структуры кода, а структура определяется скобками, легко позволить редактору расставить отступы вместо вас.

В SLIME нажатие Tab в начале каждой строки приводит к тому, что строка будет правильно выровнена; также вы можете перевыровнять целое выражение, поставив курсор на открывающую скобку и набрав C-M-q. Или вы можете перевыровнять все тело функции, набрав C-c M-q, находясь где угодно в теле функции.

На самом деле, опытный Lisp-программист предпочитает полагаться на текстовый редактор, который обработает отступы автоматически, не только для того, чтобы код выглядел красиво, но и для обнаружения опечаток: как только вы привыкните к правильной расстановке отступов в коде, так сразу начнёте легко обнаруживать пропуск необходимой скобки по странной расстановке отступов вашим редактором. Например, предположим, что вы написали следующую функцию:

<code="lisp">
  (defun foo ()
    (if (test)
      (do-one-thing)
      (do-another-thing)))
</code>

Теперь предположим, что вы случайно не поставили закрывающую скобку после ''test''. Поскольку вы не обеспокоены подсчетом скобок, вы просто добавите ещё одну в конец формы **DEFUN**, получив следующий код:

<code="lisp">
  (defun foo ()
    (if (test
      (do-one-thing)
      (do-another-thing))))
</code>

Однако, если вы выравнивали код, нажимая Tab в начале каждой строки, вы не получите вышеприведенный код. Вместо него вы получите это:

<code="lisp">
  (defun foo ()
    (if (test
         (do-one-thing)
         (do-another-thing))))
</code>

Выравнивание веток ''then'' и ''else'', перенесенных под условие вместо того, чтобы находиться чуть правее ''if'', немедленно говорит нам, что что-то не так.

Другое важное правило форматирования заключается в том, что закрывающие скобки всегда помещаются в той же строке, что и последний элемент списка, который они закрывают. Так что не пишите так:

<code="lisp">
  (defun foo ()
    (dotimes (i 10)
      (format t "~d. hello~%" i)
    )
  )
</code>

правильный вариант:

<code="lisp">
  (defun foo ()
    (dotimes (i 10)
      (format t "~d. hello~%" i)))
</code>

Строка ))) в конце может казаться некрасивой, но когда ваш код имеет правильные отступы скобки должны уходить на второй план. Не нужно привлекать к ним несвоевременное внимание, располагая их на нескольких строках.

И, наконец, комментарии должны предваряться от одной до четырех точек с запятой, в зависимости от контекста появления этого комментария:

<code="lisp">
  ;;;; Четыре точки с запятой для комментария в начале файла

  ;;; Комментарий из трех точек с запятой обычно является параграфом комментариев,
  ;;; который предваряет большую секцию кода

  (defun foo (x)
    (dotimes (i x)
      ;; Две точки с запятой показывают, что комментарий применен к последующему коду.
      ;; Заметьте, что этот комментарий имеет такой же отступ, как и последующий код.
      (some-function-call)
      (another i)              ; этот комментарий применим только к этой строке
      (and-another)            ; а этот для этой строки
      (baz)))
</code>

Теперь вы готовы начать более детально рассматривать важнейшие строительный блоки программ Lisp: функции, переменные и макросы. Следующим шагом станут функции.